[{"title":"ISS国际空间站SSTV主题活动2024年11月","url":"/2024/11/16/ISS国际空间站SSTV主题活动2024年11月/","content":"\n## 软硬件\n\n* 自制四臂螺旋天线\n* mirisdr\n* SDRuno\n* Black Cat SSTV\n\n## 2024年11月14日\n\n![20211114-1](20241114-121008-PD120.jpg)\n\n## 2024年11月16日\n\n![20241116-1](20241116-103359-PD120.jpg)\n\n![20241116-2](20241116-103605-PD120.jpg)\n","tags":["HAM SSTV"]},{"title":"PyBind11应用","url":"/2024/11/01/PyBind11应用/","content":"\n## 问题\n\n网上思岚激光雷达的应用教程一上来就是基于ROS2系统的。这种方法可以通过GUI方式查看测试数据，直观又强大。\n\n但是如果想环境和依赖简单一点，硬件资源占用少一点，可以用思岚提供的SDK。[SDK](https://github.com/slamtec/rplidar_sdk)是以持C++源代码的方式提供的，自带例程。\n\n项目需要python读取的雷达数据。一开始是由docker中的ROS2作为数据处理和通讯的中转站。但发现占用资源多，操作有点复杂。\n\n转而考虑python直接调用sdk, 由于头文件非常多ctypes方式没怎么尝试就放弃了。中途用qt6调sdk然后通过UDP传给python，虽然数据通了，但部署得交叉编译还得依赖qt6. 性能也有损失。\n\n最后就用到主角 pybind11 (blog中搜索 **PyBind11简明教程**) 和 [外观设计模式](https://en.wikipedia.org/wiki/Facade_pattern) *实现 python 调用 cpp 的 sdk*\n\n## 工程目录\n\n```bash\n├── build\n├── CMakeLists.txt\n├── main.cpp\n├── mylib.h\n├── pywrap.cpp\n├── readme.md\n├── sdk\n│   ├── CMakeLists.txt\n│   ├── include\n│   └── src\n└── test.py\n```\n\n## 封装SDK\n\n外观设计模式简单来说就是把零散复杂的SDK根据使用流程做一个抽象和封装。\n\n让别人调用的时候不再关注流程和操作上的技术细节。\n\n比如此处的mylib.h (如果将类的实现分开写道单独的如mylib.cpp文件中，python调用的时候会报错，好像是CPP编译器给函数名增加了一些信息。)\n\n注意：\n* 本项目仅用的串口，网络通讯方式已被省略，如有需要请参考SDK例程\n* 由于udev已经将雷达串口映射为 \"/dev/rplidar\" 波特率100000 请自行修改。\n\n```hpp\n#ifndef __MY_RADAR\n#define __MY_RADAR\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n\n#include <vector>\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h> // 包含 STL 支持\nnamespace py = pybind11;\n\n#include \"sl_lidar.h\"\n#include \"sl_lidar_driver.h\"\n#ifndef _countof\n#define _countof(_Array) (int)(sizeof(_Array) / sizeof(_Array[0]))\n#endif\n\n#ifdef _WIN32\n#include <Windows.h>\n#define delay(x)   ::Sleep(x)\n#else\n#include <unistd.h>\nstatic inline void delay(sl_word_size_t ms) {\n    while (ms >= 1000) {\n        usleep(1000 * 1000);\n        ms -= 1000;\n    };\n    if (ms != 0)\n        usleep(ms * 1000);\n}\n#endif\n\nusing namespace sl;\n\n\nclass MyClass {\n\npublic:    \n    MyClass(int com)\n    {\n        IChannel* _channel;\n        sl_result     op_result;\n\n        std::cout << \"init\" << std::endl;\n\n        drv = *createLidarDriver();\n        if (!drv) {\n            fprintf(stderr, \"insufficent memory, exit\\n\");\n            exit(-2);\n        }\n        sl_lidar_response_device_info_t devinfo;\n        bool connectSuccess = false;\n\n        _channel = (*createSerialPortChannel(\"/dev/rplidar\", 1000000));\n        if (SL_IS_OK((drv)->connect(_channel))) {\n            op_result = drv->getDeviceInfo(devinfo);\n\n            if (SL_IS_OK(op_result))\n            {\n                connectSuccess = true;\n            }\n            else {\n                delete drv;\n                drv = NULL;\n            }\n        }\n\n        if (!connectSuccess) {\n            fprintf(stderr, \"Error, cannot bind to the specified serial port.\\n\");\n\n            goto on_finished;\n        }\n\n        printf(\"SLAMTEC LIDAR S/N: \");\n        for (int pos = 0; pos < 16; ++pos) {\n            printf(\"%02X\", devinfo.serialnum[pos]);\n        }\n\n        printf(\"\\n\"\n            \"Firmware Ver: %d.%02d\\n\"\n            \"Hardware Rev: %d\\n\"\n            , devinfo.firmware_version >> 8\n            , devinfo.firmware_version & 0xFF\n            , (int)devinfo.hardware_version);\n\n        // check health...\n        if (!checkSLAMTECLIDARHealth(drv)) {\n            goto on_finished;\n        }\n\n        drv->setMotorSpeed();\n        drv->startScan(0, 1);\n\n    on_finished:\n        return;\n    };\n\n    ~MyClass() {\n        std::cout << \"uninit\" << std::endl;\n        drv->stop();\n        delay(200);\n        if (drv) {\n            drv->setMotorSpeed(0);\n            delete drv;\n            drv = NULL;\n        }\n    };\n\n    void run(void) {\n        std::cout << \"run\" << std::endl;\n        if (drv) {\n            sl_lidar_response_measurement_node_hq_t nodes[8192];\n            size_t   count = _countof(nodes);\n\n            sl_result op_result = drv->grabScanDataHq(nodes, count);\n\n            if (SL_IS_OK(op_result)) {\n                drv->ascendScanData(nodes, count);\n                if (data_angle.size() != count)\n                {\n                    data_angle.resize(count);\n                    data_dist.resize(count);\n                    data_quality.resize(count);\n                }\n\n                for (int pos = 0; pos < (int)count; ++pos) {\n                    // printf(\"%s theta: %03.2f Dist: %08.2f Q: %d \\n\",\n                    //     (nodes[pos].flag & SL_LIDAR_RESP_HQ_FLAG_SYNCBIT) ? \"S \" : \"  \",\n                    //     (nodes[pos].angle_z_q14 * 90.f) / 16384.f,\n                    //     nodes[pos].dist_mm_q2 / 4.0f,\n                    //     nodes[pos].quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT);\n                    data_angle.at(pos) = (nodes[pos].angle_z_q14 * 90.f) / 16384.f;\n                    data_dist.at(pos) = nodes[pos].dist_mm_q2 / 4.0f;\n                    data_quality.at(pos) = nodes[pos].quality >> SL_LIDAR_RESP_MEASUREMENT_QUALITY_SHIFT;\n                }\n            }\n        }\n    };\n\n    const std::vector<double>& get_angle() const { return data_angle;}\n    const std::vector<double>& get_dist() const { return data_dist;}\n    const std::vector<int>& get_quality() const { return data_quality;}\n\nprivate:\n    std::vector<double> data_angle;\n    std::vector<double> data_dist;\n    std::vector<int>    data_quality;\n\n    ILidarDriver* drv;\n\n    bool checkSLAMTECLIDARHealth(ILidarDriver* drv)\n    {\n        sl_result     op_result;\n        sl_lidar_response_device_health_t healthinfo;\n\n        op_result = drv->getHealth(healthinfo);\n        if (SL_IS_OK(op_result)) { // the macro IS_OK is the preperred way to judge whether the operation is succeed.\n            printf(\"SLAMTEC Lidar health status : %d\\n\", healthinfo.status);\n            if (healthinfo.status == SL_LIDAR_STATUS_ERROR) {\n                fprintf(stderr, \"Error, slamtec lidar internal error detected. Please reboot the device to retry.\\n\");\n                // enable the following code if you want slamtec lidar to be reboot by software\n                // drv->reset();\n                return false;\n            }\n            else {\n                return true;\n            }\n\n        }\n        else {\n            fprintf(stderr, \"Error, cannot retrieve the lidar health code: %x\\n\", op_result);\n            return false;\n        }\n    }\n};\n\n\n#endif\n```\n\n虽然内容很多，但对于 python 上层调用方来讲。就只有\n\n* 构造函数：雷达初始化，完成准备工作\n* run函数：串口将雷达数据保存到私有变量\n* get_angle/get_dist/data_quality等数据传递函数：从私有变量将数据传递给python\n* 析构函数：关闭雷达释放资源\n\n这也是上面提到的 **外观设计模式**\n\n## 创建 python 包装器所需的内容\n\n照猫画虎实现的 pywrap.cpp 文件\n\n```cpp\n#include <pybind11/pybind11.h>\n#include \"mylib.h\"\n\nnamespace py = pybind11;\nconstexpr auto byref = py::return_value_policy::reference_internal;\n\nPYBIND11_MODULE(MyLib, m) {\n    m.doc() = \"optional module docstring\";\n\n    py::class_<MyClass>(m, \"MyClass\")\n    .def(py::init<int>())\n    .def(\"run\", &MyClass::run, py::call_guard<py::gil_scoped_release>())\n    .def(\"get_angle\", &MyClass::get_angle)\n    .def(\"get_dist\", &MyClass::get_dist)\n    .def(\"get_quality\", &MyClass::get_quality)\n    ;\n}\n```\n\n## 前期调试\n\n此文件仅用于前期验证库文件功能是否正常\n\nmain.cpp\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n\n#include \"sl_lidar.h\" \n#include \"sl_lidar_driver.h\"\n\n#include \"mylib.h\"\n\n\nint main(int argc, const char* argv[]) {\n    MyClass radar(1);\n    radar.run();\n    return 0;\n}\n```\n\n## 编译生成库文件\n\n安装 pybind11。安装方式除了下面，还有 pip 和 conda 等\n\n```bash\nsudo apt install pybind11-dev\n```\n\n将 sdk 和 pybing11 教程中的 cmake 文件结合到一起（注意pybind11_DIR 文件目录根据自己的实际情况修改）\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\n\nproject(MyLib)\n\nset(CMAKE_CXX_STANDARD 11)\nset(PYBIND11_PYTHON_VERSION 3.6)\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -fPIC\")\n\nset(pybind11_DIR \"/usr/local/lib/python3.6/dist-packages/pybind11/share/cmake/pybind11\")\nfind_package(pybind11 REQUIRED)\nfind_package(Threads REQUIRED)\n\n# 静态库生成的路径\nset(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)\n# 第三方库头文件路径\nlist(APPEND HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/sdk/include)\nlist(APPEND HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/sdk/src)\n# 静态库的名字\nset(RADRA_LIB \"rplidar_driver\")\n\n# 添加子目录\nadd_subdirectory(sdk)\n\ninclude_directories(${HEAD_PATH})\n\nlink_directories(${LIB_PATH})\n# link_libraries(${RPLIDAR_LIB})\n\npybind11_add_module(${PROJECT_NAME} pywrap.cpp)\n\n# exe 前期编写main.cpp调库调试功能，后面生成库供python调用（exe 和 so 不能同时启用）\n# file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)\n# add_executable(app ${SRC_LIST})\n# target_link_libraries(app ${RADRA_LIB} Threads::Threads)\n\n# so\ntarget_compile_definitions(${PROJECT_NAME} PRIVATE VERSION_INFO=${EXAMPLE_VERSION_INFO})\ntarget_include_directories(${PROJECT_NAME} PRIVATE ${PYBIND11_INCLUDE_DIRS})\ntarget_link_libraries(${PROJECT_NAME} PRIVATE ${RADRA_LIB} Threads::Threads)\n```\n\n编译库\n\n```bash\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n顺利的话会生成类似 `MyLib.cpython-36m-aarch64-linux-gnu.so` 文件\n\n## python 调用\n\ntest.py\n```python\nimport sys\nimport numpy as np\nsys.path.append(\"build/\")\nfrom MyLib import MyClass\n\nradar = MyClass(1)\n\nwhile True:\n    radar.run()\n    l_angle = radar.get_angle()\n    l_dist = radar.get_dist()\n    l_quality = radar.get_quality()\n    print(l_angle)\n```\n\n测试\n\n```bash\npython3 test.py\n```\n可以按 `Ctrl+C` 停止","tags":["Python C/C++"]},{"title":"OhMyZsh_powerlevel10k快速打造好看好用的Terminal","url":"/2024/10/26/OhMyZsh-powerlevel10k快速打造好看好用的Terminal/","content":"\n[原帖](https://holychung.medium.com/%E5%88%86%E4%BA%AB-oh-my-zsh-powerlevel10k-%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%A5%BD%E7%9C%8B%E5%A5%BD%E7%94%A8%E7%9A%84-command-line-%E7%92%B0%E5%A2%83-f66846117921)\n\n## 前情提要\n\n此篇是以 ubuntu 20.04 作為範例，同時也可以使用在 mac、windows WSL 當中，稍微會有一點不同的設定可以參考 [My_Terminal_Theme](https://github.com/Holychung/My_Terminal_Theme)\n\n![最終成果](pic1.gif)\n\n## 安裝、設定方式\n\n總共有以下步驟：\n\n* 安裝 zsh\n* 安裝 oh-my-zsh\n* 安裝 zsh theme: powerlevel10k\n* 安裝 zsh 好用 plugins\n* 安裝 powerline font\n* 修改 powerlevel10k 設定\n* 修改 terminal 的 color scheme\n* 固定指令列在終端機底部\n\n首先，如果 ubuntu 系統是剛灌完，建議利用下面兩步驟先更新一下，如果是舊玩家直接跳過這一步驟進入 zsh 基本安裝即可。\n\n```bash\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n順便把一些套件裝一下。\n\n```bash\nsudo apt install vim curl git\n```\n\n## 安裝 zsh\n\n```bash\nsudo apt install zsh\n```\n\n如果裝好了可以用這個指令查看。\n\n```bash\ncat /etc/shells\n```\n\n更換 login shell，要記得 logout 才會生效。\n\n```bash\nchsh -s $(which zsh)\n```\n\n## 安裝 oh-my-zsh\n\n[ohmyzsh github](https://github.com/ohmyzsh/ohmyzsh)\n\n```bash\nwget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh\nsh install.sh\n```\n\n## 安裝 zsh theme: powerlevel10k\n\n[powerlevel10k github](https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#meslo-nerd-font-patched-for-powerlevel10k)\n\nOh My Zsh 安裝 powerlevel10k。\n\n```bash\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n```\n\n安裝好後要修改 zsh 設定檔 .zshrc，先把主題換成剛剛安裝的 powerlevel10k\n\n```vim\nZSH_THEME=\"powerlevel10k/powerlevel10k\"\n```\n\n然後下這個指令。\n\n```bash\nsource ~/.zshrc\n```\n\n可以去對 prompt 做基本的設定，包含 prompt style 等。\n\n```bash\np10k configure\n```\n\n## 安裝字型\n\nPowerlevel10k 推薦使用 Meslo Nerd Font。\n\n* [MesloLGS NF Regular.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf)\n* [MesloLGS NF Bold.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf)\n* [MesloLGS NF Italic.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf)\n* [MesloLGS NF Bold Italic.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf)\n\n下載好後，修改 GNOME Terminal (the default Ubuntu terminal) 步驟如下。\n`Open Terminal` → `Preferences` and click on the selected profile under Profiles. Check Custom font under `Text Appearance` and select `MesloLGS NF Regular`.\n\n如果是 xfce4 双击字体文件没有安装选项时，需安装[font-manager](https://askmeaboutlinux.com/2023/10/04/how-to-add-fonts-on-the-xfce-desktop-in-linux/) \n\n```bash\nsudo apt-get install thunar-font-manager\nfont-manager\n```\n\n![Terminal Settings](TerminalSettings.jpg)\n\n## 安裝 zsh 好用 plugins\n\n* [zsh-completions](https://github.com/zsh-users/zsh-completions)\n* [zsh-autosuggestions](https://github.com/zsh-users/zsh-autosuggestions)\n* [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting)\n\n裝好後修改 .zshrc 把 plugins 加到設定檔。\n\n```vim\nplugins=(\ngit\nzsh-completions \nzsh-autosuggestions \nzsh-syntax-highlighting\n)\n```\n\n立即生效。\n\n```bash\nsource ~/.zshrc\n```\n\n## 修改 powerlevel10k 設定\n\n設定檔 `.p10k.zsh`，修改完要下 `source ~/.p10k.zsh`。\n\n這邊我只簡單介紹兩個我有修改的東西，其他也是差不多改法，可以參考 [powerlevel10k](https://github.com/romkatv/powerlevel10k) 有很詳細的說明。\n\n修改 prompt 資料夾路徑如果太長超過過一個長度，中間的資料夾名稱會變成縮寫如下圖，這邊我把它改成大於 20 個字，不過可以視自己螢幕大小修改。\n\n`typeset -g POWERLEVEL9K_DIR_MAX_LENGTH=20`\n\n修改 prompt 當前目錄的顏色，這邊可以參考 directory-is-difficult-to-see-in-prompt-when-using-rainbow-style 有很詳細的說明，底下是我自己更改的版本還要配合修改 terminal 的 color scheme，也可以依照自己喜好修改。\n\n```\n# Current directory background color.\ntypeset -g POWERLEVEL9K_DIR_BACKGROUND=4\n# Default current directory foreground color.\ntypeset -g POWERLEVEL9K_DIR_FOREGROUND=0\n# If directory is too long, shorten some of its segments to the shortest possible unique\n# prefix. The shortened directory can be tab-completed to the original.\ntypeset -g POWERLEVEL9K_SHORTEN_STRATEGY=truncate_to_unique\n# Replace removed segment suffixes with this symbol.\ntypeset -g POWERLEVEL9K_SHORTEN_DELIMITER=\n# Color of the shortened directory segments.\ntypeset -g POWERLEVEL9K_DIR_SHORTENED_FOREGROUND=232\n# Color of the anchor directory segments. Anchor segments are never shortened. The first\n# segment is always an anchor.\ntypeset -g POWERLEVEL9K_DIR_ANCHOR_FOREGROUND=232\n# Display anchor directory segments in bold.\ntypeset -g POWERLEVEL9K_DIR_ANCHOR_BOLD=false\n```\n\n## 修改 terminal 的 color scheme\n\n這邊提供我自己改的顏色，有參考 Windows Terminal Themes 當中的 Brogrammer，還有 Mac 的 terminal 進行修改。\n\n```\n{\n  \"black\": \"#1f1f1f\",\n  \"red\": \"#f81118\",\n  \"green\": \"#85D29A\",\n  \"yellow\": \"#ecba0f\",\n  \"blue\": \"#5C97CF\",\n  \"purple\": \"#4e5ab7\",\n  \"cyan\": \"#1081d6\",\n  \"white\": \"#ffffff\",\n  \"brightBlack\": \"#d6dbe5\",\n  \"brightRed\": \"#de352e\",\n  \"brightGreen\": \"#1dd361\",\n  \"brightYellow\": \"#f3bd09\",\n  \"brightBlue\": \"#1081d6\",\n  \"brightPurple\": \"#5350b9\",\n  \"brightCyan\": \"#0f7ddb\",\n  \"brightWhite\": \"#ffffff\",\n\n  \"background\": \"#2D2D2D\",\n  \"foreground\": \"#d6dbe5\"\n}\n```\n\n## 固定指令列在終端機底部\n\n可以在 .zshrc 當中加入這行，把命令列固定在最底下，視線就不用一直改動，我自己是很喜歡這個功能，不過這個有時候會有一些時候還是會跑掉，e.g. 下 clear 指令的時候，期待有人能找到更好的方法XD\n\n```\n# Fix prompt at the bottom of the terminal window\nprintf '\\n%.0s' {1..100}\n```\n\n## 最後\n\n如果有看到哪個地方可以修改的或是有不錯的套件歡迎告訴我，一起打造一個高效率的開發環境。\n\n歡迎參考 [My_Terminal_Theme](https://github.com/Holychung/My_Terminal_Theme) 當中的配置，也可以找到 Mac、WSL 的版本，都是可行的。\n\n[Mac 設定](https://github.com/Holychung/My_Terminal_Theme/tree/main/mac)\n\n[Windows WSL 設定](https://github.com/Holychung/My_Terminal_Theme/tree/main/WSL)\n\n[作者Blog](https://holychung.github.io/)\n","tags":["Linux"]},{"title":"neovim和插件","url":"/2024/10/20/neovim和插件/","content":"\n## 安装neovim\n\n[neovim-releases](https://github.com/neovim/neovim-releases/releases)下载安装包\n\n```bash\nsudo dpkg -i  nvim-linux64.deb\n```\n\n## 新建配置文件\n\n[kickstart.nvim](https://github.com/nvim-lua/kickstart.nvim)\n\n[YouTube教程](https://youtu.be/stqUbv-5u2s?si=MZ-nfA6-Y0KOlqe9)\n\n```bash\ngit clone https://github.com/nvim-lua/kickstart.nvim.git \"${XDG_CONFIG_HOME:-$HOME/.config}\"/nvim\n```\n\n## 使用\n\n### 命令\n\n`:Lazy` 插件状态\n\n`:Mason` LSP自动补全插件\n\n`:Telescope keymap`\n\n### 快捷键\n\n`C+F` 查找  `i` 安装\n\n`C+N` 下一条  `C+P` 上一条 `C+Y` 接受\n\n`[` `]` 跳转\n\n`leader` 被配置为 Space空格键\n\n`<leader>?` 最近打开的文件\n\n`<leader><leader>` 当前打开的缓冲区\n\n`<leader>/` 当前文件搜索\n\n`gd` Goto Definiton\n\n`gr` Goto References\n\n`gI` Goto Implementation\n\n","tags":["nvim"]},{"title":"VsCode中使用PlatformIO","url":"/2024/10/19/VsCode中使用PlatformIO/","content":"\n## 安装 Visual Studio Code\n\n在 [官网](https://code.visualstudio.com/download) 下载 .deb 安装包\n\n使用下面的指令安装（注意修改文件名）\n\n```bash\nsudo dpkg -i code_1.94.2-1728494015_amd64.deb\n```\n\n## 从开始菜单打开 Visual Studio Code\n\n点击插件 (Ctrl + Shift + X)，搜索 PlatformIO 点击安装\n\n如果PlatformIO弹窗提示没有找到python，我的系统已经安装了python3.11\n\n此时需要安装 python3-venv 参考[链接](https://community.platformio.org/t/ubuntu-vscode-pio-extension-install-platformio-can-not-find-working-python-3-6-interpreter/27853/3)\n\n```bash\nhttps://community.platformio.org/t/ubuntu-vscode-pio-extension-install-platformio-can-not-find-working-python-3-6-interpreter/27853/3\n```\n\n继续安装\n\n## 串口权限\n\n通过串口下载程序，提示没有权限。此时需要根据提示配置udev\n\n参考链接 [99-platformio-udev.rules](https://docs.platformio.org/en/stable/core/installation/udev-rules.htmlhttps://docs.platformio.org/en/stable/core/installation/udev-rules.html)\n\n下载并将文件复制到 `/etc/udev/rules.d/` 文件夹中\n\n重启udev服务 `sudo service udev restart`\n\n查看串口所属组名，如下面的 `dialout`\n\n```bash\nls -l /dev/ttyACM0\n# crw-rw---- 1 root dialout 166, 0 juil. 10 13:43 /dev/ttyACM0\n```\n\n将当前用户加入到 `dialout` 组\n\n```bash\nsudo usermod -a -G dialout $USERNAME\n```\n\n注销后重新登陆","tags":["PlatformIO"]},{"title":"调整电脑启动顺序","url":"/2024/10/19/调整电脑启动顺序/","content":"\n## 问题\n\n虽然Ubuntu 刚开始安装完成后，电脑默认会通过GRUB启动。但是 Windows 经常会越过 GRUB 直接启动。\n\n此时只能在开机后通过 BIOS 自带启动选项，手动选择GRUB。非常麻烦。\n\n## 解决\n\n链接 [How to make UEFI bios start GRUB, not Windows?](https://superuser.com/questions/1247300/how-to-make-uefi-bios-start-grub-not-windows)\n\n我使用的是\n\nefibootmgr -- This Linux tool can adjust the boot order. Begin by typing sudo efibootmgr alone to see the options. Note the number (Boot####) associated with the ubuntu entry, and the current boot order (on the BootOrder line). You can then enter a new boot order with the ubuntu entry at the top by using the -o option. For instance, if the current boot order is 0000,0003,0007,0004 and ubuntu is 0007, you'd type sudo efibootmgr -o 0007,0000,0003,0004 to adjust the boot order.\n\n\nefibootmgr -- 这个 Linux 工具可以调整启动顺序。 首先单独输入 sudo efibootmgr 查看选项。 注意与 ubuntu 条目相关的编号（Boot####）和当前启动顺序（在 BootOrder 行）。 然后，你可以使用 -o 选项输入一个新的启动顺序，将 ubuntu 条目放在最前面。 例如，如果当前的启动顺序是 0000,0003,0007,0004，而 ubuntu 是 0007，你就可以输入 sudo efibootmgr -o 0007,0000,0003,0004 来调整启动顺序。\n","tags":["linux"]},{"title":"vim安装coc-nvim插件实现代码补全","url":"/2024/10/06/vim安装coc-nvim插件实现代码补全/","content":"\n## vim 插件管理器\n\n[vim-plug](https://github.com/junegunn/vim-plug) Minimalist Vim Plugin Manager \n\n### 安装\n\n```bash\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n```\n\n### 使用\n\nedit `~/.vimrc`\n\n```vim\ncall plug#begin()\n\n\" List your plugins here\nPlug 'tpope/vim-sensible'\n\ncall plug#end()\n```\n\n重启 vim, 即可执行以下命令\n\n* `:PlugInstall` to install the plugins\n* `:PlugUpdate` to install or update the plugins\n* `:PlugDiff` to review the changes from the last update\n* `:PlugClean` to remove plugins no longer in the list\n\n\n## coc.nvim 插件\n\n[coc.nvim](https://github.com/neoclide/coc.nvim) Make your Vim/Neovim as smart as VS Code\n\n编辑 `~/.vimrc` 加入 vim-plug 插件列表\n\n```vim\n\" Use release branch (recommended)\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\n\n\" Or build from source code by using npm\nPlug 'neoclide/coc.nvim', {'branch': 'master', 'do': 'npm ci'}\n```\n\n重启 vim 然后执行 `:PlugInstall` 命令安装coc.nvim\n\n安装完成后，再次编辑 `~/.vimrc` 加入默认配置参数(快捷键等) [链接](https://github.com/neoclide/coc.nvim#example-vim-configuration)\n\n## c/c++ 补全插件\n\n[coc-clangd](https://github.com/clangd/coc-clangd) clangd extension for coc.nvim \n\nvim 中执行 `:CocInstall coc-clangd` 安装插件，此插件用于连接下一小节安装的clangd服务\n\n修改配置参数 `:CocConfig` ，配置参数也可参考[llvm.org](https://clangd.llvm.org/installation.html) \n\n```vim\n{\n  \"clangd.arguments\": [\"--background-index\", \"--clang-tidy\"],\n  \"clangd.fallbackFlags\": [\"-std=c++23\"]\n}\n```\n\n## 安装 clangd\n\n[llvm.org](https://clangd.llvm.org/installation.html) 中 Editor plugins 小节\n\n```bash\nsudo apt install clangd\n```\n\n## 使用\n\nvim新建main.cpp文件编写代码\n\nCoc快捷键：\n\n1. `Tab`切换补全 `Enter`确认\n2. `gd` to jump to definition\n3. `gr` for references\n4. `gy` for type definition\n5. `K`  for documentation\n6. `<leader>rn` for renaming  `<leader>`默认为 `\\` 按键\n7. `if`, `ic` for func/class selection in visual mode\n8. `<space>a` to list diagnostics\n9. `[g` and `]g` to go prev/next in diagnostics\n10. `Ctrl+o` 在普通模式下，按 Ctrl + o 可以返回到上一个光标位置\n11. `Ctrl+i` 可以前进到下一个光标位置（即回到使用 Ctrl + o 返回的地方）\n\n## 其他插件\n\n1. auto-pairs 自动补括号\n2. fzf 文件搜索\n3. nerdtree 文件列表\n4. lightline 好看的状态栏\n\n```vim\ncall plug#begin()\n\nPlug 'jiangmiao/auto-pairs'\nPlug 'junegunn/fzf', { 'do': { -> fzf#install() } }\nPlug 'junegunn/fzf.vim'\n\"Plug 'voldikss/vim-floaterm'\nPlug 'preservim/nerdtree', { 'on': 'NERDTreeToggle' }\nPlug 'itchyny/lightline.vim'\nPlug 'neoclide/coc.nvim', { 'branch': 'release' }\n\ncall plug#end()\n```\n\n","tags":["vim"]},{"title":"nodejs安装","url":"/2024/10/06/nodejs安装/","content":"\n## 简介\n\n### 维基百科\n\nNode.js 是跨平台、开源的 JavaScript 运行环境，可在 Windows、Linux、macOS 等操作系统上运行。\n\nNode.js 大部分基本模块都用 JavaScript 语言编写。在 Node.js 出现之前，JavaScript 通常作为客户端程序设计语言使用，以JavaScript 写出的程序常在用户的浏览器上执行。Node.js 的出现使 JavaScript 也能用于服务端编程。Node.js 含有一系列内置模块，使得程序可以脱离 Apache HTTP Server 或 IIS，作为独立服务器执行。 \n\n[wikipedia](https://zh.wikipedia.org/zh-cn/Node.js)\n\n### 个人理解\n\n在 Node.js 出现之前，JavaScript 是在浏览器中执行的，主要用于前端开发。Node.js 为 JavaScript 提供了一个独立运行环境，而无需依赖浏览器，使其能够用于编写后端逻辑。\n\n## 软件\n\n### 管理 Node.js\n\n安装和切换 Node.js 的不同版本\n\n[nvs](https://github.com/jasongin/nvs) (Node Version Switcher)。\n\n```bash\nnvs\nnvs add latest\nnvs add lts\nnvs add <version>\nnvs use lts\nnvs use <version>\nnvs list\nnvs link lts\nnvs alias default <version>\n```\n\n[nvm](https://github.com/nvm-sh/nvm) (Node Version Manager)\n\n### 管理包\n\n用于安装和管理 JavaScript 包\n\n[npm](https://www.npmjs.com/) (Node Package Manager) npm 是 Node.js 的默认包管理器。\n\n```bash\nnpm install <package-name>\nnpm install -g <package-name>\nnpm uninstall <package-name>\n```\n\n[yarn](https://yarnpkg.com/) 是Facebook 开发的一个替代 npm 的包管理工具\n\n```bash\nyarn add <package-name>\nyarn remove <package-name>\nyarn upgrade <package-name>\n```\n\n### npx\n\nnpx 是 npm 附带的工具，用于执行 npm 包中的命令，而无需全局安装它们。\n\n```bash\nnpx <package-name>\nnpx <package-name>@<version>\n```\n","tags":["Node.js"]},{"title":"CPP学习笔记","url":"/2024/09/06/CPP学习笔记/","content":"\n视频教程： [youtube 侯捷](https://www.youtube.com/watch?v=2S-tJaPKFdQ&list=PL-X74YXt4LVZ137kKM5dNfCIC4tsScerb)\n\n## P1\n\n类分两种，思考方式完全不同：\n\n**无指针**:多半不用写析构函数\nclass without pointer members (Complex 复数)\n\n**有指针**:要写析构函数\nclass with pointer members (String 字符串)\n\n\n类之间的关系：\n\n**继承**inheritance、**复合**composition、**委托**delegation\n\n单一class:     Object Based：   基于对象\n\nclass间有关联：Object Oriented: 面向对象\n\nc++(C++语言 C++标准库) 推荐书籍\n\n## P2\n\nc 变量为全局\n\nc++ 变量和对象绑定(c++中的class和struct区别很小)\n\nc   无指针 数据多个地方 函数一份\n\nc++ 有指针 数据是一个指针 函数一份 具体数据多个地方\n\nc   标准库\n\n`include <stdio.h> == <cstdio>`\n\nc++ 标准库 (include 可以不带.h后缀)\n\n`include <iostream.h> == <iostream>`\n\n标准库 `std::cout <<` 接收基本类型，其他复杂类型需要自己写符号重载函数\n\n```cpp\n.h 防卫式声明\n#ifndef __COMPLEX__\n#define __COMPLEX__\n...\n#endif\n```\n\n一个类满足多种数据类型 使用模板 在使用的时候来确定\n\n`template<typename T>`\n\n类里面使用T来代替未确定类型的变量，以后使用：\n\n```cpp\ncomplex<double> c1(2.5, 1.5);\ncomplex<int> c2(2, 6);\n```\n\n## P3\n\ninline 函数 快 放置在class 的 {body} 中，或者函数前加 inline。 复杂的函数即使写inline也没用 全部写inline也没关系\n\n类使用的三种方式:\n```cpp\ncomplex c1(1,2);\ncomplex c2;\ncomplex *c3 = new complex(1, 2);\n```\n\n```cpp\nnew delete\narray new delete array //需要调用多次析构函数 不然只会调用一次析构函数\n```\n\n字符数组\n\n```cpp\nclass complex\n{\npublic:\n    complex (double r=0, double i=0)\n        : re (r), im (i)\n    {}\n    comple& operator += (const complex&);\n    double real () const {return re;}\n    double imag () const {return im;}\nprivate:\n    double re im;\n    \n    friend complex& __doapl (comple*, const complex&);\n};\n```\n\n数据全部放到private中，函数主要放在public，如果不想让别人调用就放到private中。\n\n成员函数 非成员函数\n\n重载 函数的参数一定不能一样 编译器看到的函数实际为（函数名+参数） 注意参数默认值的问题\n\n`complex (double r = 0, double i = 0) : re (r), im(i){}`\n\n构造函数：1默认值 2初始化列表（仅构造函数有此功能） 3多态\n构造函数一定返回的是一个对象，故不需要写返回值\n\n## P4\n\n把构造函数写在private中，表示不能被外部调用，即不能实现类的声明和定义。\n\n有种设计模式Singleton，利用将构造函数写到private中来实现仅会创建一个对象的功能。\n\n`double real () const {return re;}`\n若函数不会去改变类中的数据，需要在函数()和{}中间加 `const` 防止 用户定义一个 `const complex c1(1,2)` 在使用时 `c1.real();` 会出现错误。\n\n函数参数及返回值尽量传引用，若参数值较长，传参数会将参数值复制到栈，而引用仅会传一个地址：\n\n```cpp\npass by value\npass by reference(to const)\nretnrn by value\nreturn by reference\n```\n\n`comple& operator += (const complex&);`\n\n若参数值不会改变则加入const标识，引用和指针效果类似，函数中改变引用也会改变变量的值。\n\n相同class的各个objects互为friends友元（可以使用private私有数据）\n不是新的局部变量，所以可以传引用。\n\n返回值：如返回值不是新变量(局部变量)的则返回引用 如i++\n\n返回值：如返回值需要产生新的变量，则传变量不然函数结束临时变量的引用也就丢失了 如c = a+b 不可传c的引用\n\n返回值：引用可方便用户实现 cout << real () << real() 等运算方式， 因为执行顺序特殊是从左到右，第一次输出后含需要接收，产生第二次输出；\n\n## P5\n\n操作符重载 所有操作符都是为了作用到左边\n\n```cpp\ninline complex&       //单独提出来也许其他地方也在用\n__doapl(complex* ths, const const complex& r)\n{\n    ths->re += r.re;\n    ths->im += r.rm;\n    return *ths;\n}\n\ninline complex&\ncomplex::operator += (const complex& r)\n{\n    return __doapl(this, r);\n}\n```\n\n返回reference 是为了连续使用 如  c3+=c2+=c1; 为了应对如下:\n\n```cpp\n{\n    complex c1(2,1);\n    complex c2;\n    \n    c2 = c1 + c2;\n    c2 = c1 + 5;\n    c2 = 7  + c1;\n}\n```\n\n所以要写非成员函数的操作符重载 因为返回的是产生了新的数据，所以只能返回value，不可以是reference\n\n```cpp\ninline complex\noperator + (const compled& x, const complex& y)\n{\n    return complex( real(x) + real(y),\n                    imag(x) + imag(y));\n}\n\ninline complex\noperator + (const compled& x, double y)\n{\n    return complex( real(x) + y, imag(x));\n}\n\ninline complex\noperator + (double x, const complex& y)\n{\n    return complex( x + real(y), imag(y));\n}\n```\n\ncomplex ();  ==>  typename();  用来创建临时对象，但不给其名称 类似 int(xxx);\n```cpp\n{\n    int(7);\n    complex c1(2,1);\n    complex c2;\n    complex ();\n    complex (4,5);\n    \n    cout <<complex(2);\n}\n```\n\n类::函数名  是  成员函数 有this\n\n函数名      是  全域函数 无this\n\n对于 `<<` 符号的重载只能用全域函数\n\ncout 不认识complex类，所以需要自己写操作符重载函数，并且需要将 << 重载运算写成全域函数，如果是类函数，默认会带this指针，使用方式会反成 a << cout 而不是 cout << a;\n所有的成员函数，默认包含一个参数*this，this指针谁调用，指向谁。\n\n``` cpp\n#include <iostream.h>\nostream&\noperator << (ostream& os, const complex& x)\n{\n    return os << '(', << real(x) << ',' << imag(x) << ')';\n}\n```\n\n构造函数不带指针的类，编译器会自己增加拷贝构造和拷贝复制函数\n\n## P6 复习\n\n## P7\n\n构造函数的参数带指针  需要写析构函数\n\nbig three: **拷贝构造** **拷贝复制** **析构**\n\n```cpp\n{\n    String s1(\"hello\");\n    String s2(s1);    //拷贝构造\n    String s2 = s1;   //拷贝赋值\n}\n```\n\n```cpp\nclass String\n{\npublic:\n    String(const char* cstr = 0);\n    String(const String& str);\n    String& operator = (const String& str);\n    ~String();\n    char* get_c_str() const {return m_data;}\nprivate:\n    char* m_data;\n};\ninline String::String(const char* cstr = 0)\n{\n    if(cstr) {\n        m_data = new char[strlen(cstr)+1];              //一定要 +1 用来存储结束符 '\\0'\n        strcpy(m_data, cstr);\n    }\n    else {\n        m_data = new char[1];\n        *m_data = '\\0';\n    }\n}\ninline String::~String()\n{\n    delete[] m_data;\n}\n```\n\n使用：\n\n```cp\n{\n    String s1();\n    String s2(\"hello\");\n    \n    String* p = new String(\"hello\");\n    delete p;\n}\n```\n\n**浅拷贝**(别名)  问题：两个变量控制同一块内存  一个变量原来的数据没有指针\n\n**深拷贝**(数据相同的两个变量)\n\n编译器默认给出的是浅拷贝，需要自己写拷贝构造函数\n\n经典写法三步走 **删除** **新建** **拷贝**\n\n```cpp\ninlin\nString& String::operator=(const String& str)\n{\n    if(this == &str)   //检测自我赋值\n        return *this;\n    delete[] m_data;\n    m_data = new char[strlen(str.m_data)+1];\n    strcpy(m_data, str.m_data);\n    return *this;\n}\n```\n\n## P8 堆 栈 内存管理\n\n本章只针对 new 这种动态分配的用法\n```cpp\nComplex c1(1,2);                   //全局对象 直到程序结束\n{\n    Complex c1(1,2);               //离开作用域 c1 调析构 然后自动清除\n    Complex* p = new Complex(3);   //离开作用域 p所指内存 还存在  需要手动释放\n    static Complex c2(1,3);        //离开作用域 c2还存在，直到程序结束\n    \n    delete p;                      //手动释放\n}\n\n{\n    Complex* p = new COmplex(3);   //离开作用域 p所指内存还存在，但p已消失，造成内存无法回收\n}\n```\n\n`new`   ：分配内存 数据类型转换 调用构造函数\n\n`delete`：调用析构函数 释放内存\n\n动态内存分配详解：  16的倍数 不够填0\n\n单个对象的情况：\n上下Cooke 4字节*2  内容是分配长度，最后一位代表 空闲 or 使用\n调试模式会多出\n固定字符 上4字节*8 下4字节\n实际内容\n\n数组的情况：\ndebug 和 release 会再实际内容之前加数组长度\n\n`new []`   //array\n\n`delete []`\n\n单一或数组形式都会有Cooke记录分配内存的长度，但数组形式的delete如果没有搭配[] 会造成对象的析构函数仅调用一次，无法将对象构造时申请的内存删除，进而造成内存泄露。\n所以若构造函数没有内存分配，使用delete不会出问题。但不可以这样用。\n\n## P9 复习String类的实现过程\n\n## P10 类模板 函数模板\n\n在变量或函数前加 static 它就是静态变量或静态函数\n\n在对象实例化的时候，产生的时不包含静态部分的数据；\n\n静态函数没有this指针，不能传递调用来源，所以只能操作静态变量；\n\n```cpp\nclass Account {\npublic:\n    static double m_rate;\n    static void set_rate(const double& x) {m_rate = x;}\n};\ndouble Account::m_rate = 8.0;  //必须如此赋初值，类中仅有对象有声明，还必须在此定义，初值可有可无；\n```\n\n调用静态函数的两种方式\n```cpp\nint main()\n{\n    Account::set_rate(5.0);  //通过类名调用 class name\n    \n    Account a;\n    a.set_rate(7.0);         //通过对象调用 object   特殊点在于没有this\n}\n```\n\nSingleton 设计模式  唯一\n\n```cpp\nclass A {\npublic:\n    static A& getInstance();\n    setup() {...}\nprivate;\n    A();;\n    A(const A& rhs);\n    ...\n};\nA& A::getInstance()\n{\n    static A a;\n    return a;\n}\n```\n\n优点只有在使用个体Instance() 函数时才会创建a\n调用: `A::getInstace().setup();`\n    \n\n类模板 `class template`  使用一个符号标识一种数据类型\n\n```cpp\ntemplate<typename T>\nclass complex\n{\npublic:\n    complex (T r = 0, T i = 0)\n        : re (t), im (i)\n    {}\n    complex& operator += (const complex);\n    T real () const {return re;}\n    T imag () const {return im;}\nprivate:\n    T re, im;\n    \n    friend complex& __doapl (complex*, const const complex&);\n}\n{\n    complex<double> c1(2.5, 1.5);\n    complex<int> c2(2, 6);\n    ...\n}\n```\n\n函数模板 `function template`\n```cpp\ntemplate <class T>\ninline\nconst T& min(const T& a, const T& b)\n{\n    return b < a ? b : a;\n}\n\nstone r1(2, 3), r2(3,3), r3;\nr3 = min(r1, r2);\n```\n\n编译器不知道stone如何比大小，所以再增加操作符重载\n```cpp\nclass stone\n{\npublic:\n    stone(int w, int h, int we)\n        : _w(w), _h(h), _weight(we)\n            {    }\n    bool operator< (const stone& rhs) const\n        {    return _weight < rhs._weight;  }\nprivate:\n    int _w, _h, _weight;\n};\n```\n\n如何建立自己的命名空间 可以分段写\n```cpp\nnamespace std\n{\n   ...\n}\n```\n\n如何使用:\n\n用法1 using directive  全部打开\n```cpp\n#include <iostream.h>\nusing namespace std;\n\nint main()\n{\n    cin << ...;\n    cout << ...;\n    return 0;\n}\n```\n\n用法2 using declaration  打开一条 如下打开cout 而cin没打开\n```cpp\n#include <iostream.h>\nusing std::cout;\n\nint main()\n{\n    std::cin << ...;\n    cout << ...;\n    return 0;\n}\n```\n\n用法3   完整书写\n\n```cpp\n#include <iostream.h>\n\nint main()\n{\n    std::cin << ...;\n    std::cout << ...;\n    return 0;\n}\n```\n\n## 面向对象\n\n## P11 组合与继承\n\n复合 Composition\n\nclass中含有另一个class  **(has a)**  让Sequence帮queue实现功能\n设计模式 Adapter 变压器、转换器\n```cpp\ntemplate <class T, class Sequence = deque<T>>\nclass queue {\n    ...\nprotected:\n    Sequence c;    //重点 queue中有个Sequence(底层容器)\npublic:\n    bool empty() const {return c.empty();}\n    \n    void push (const value_type& x) {c.push_back(x);}\n    void pop() {c.pop_front();}\n};\n```\n生命周期(一起出现或消失，仅有先后顺序)\n\n创建过程 先内部 后外部  (基础扎实)\n\n外部构造函数会帮我们调用内部的构造函数，但仅会调用默认的构造函数，如果不适用需要自己写清楚\n```cpp\nContainer::Container(...) : Component() {...};     //Component()是编译器帮我们加的 不适用就自己主动写\n```\n\n析构过程 先外部 后内部  (层层剥开)\n```cpp\nContainer::~Container(...){... ~Component()};   //~Component() 是编译器帮我们加的\n```\n\n委托 Delegation (Composition by reference)\n\n从来不讲 by point，因为学术界只讲 by reference 传指针也归类为 by reference  **class中含有另一个class的指针**\n\n至于什么时候真的有另一个class不确定\n生命周期 不同步，没有先后，需要谁创建谁。\n可以实现类似接口的功能，对外的class不变，内部函数的变化不影响外部。 也叫编译防火墙   Handle/Body(头和身体)\n\n继承 Inheritance\n\nclass中含有另一个class, 表示 **is-a**  子类中有父类的成分part 包含数据和函数的调用权\n\n创建过程 先内部父类 后外部子类  (基础扎实)         子类构造函数会帮我们调用父类的构造函数，但仅会调用默认的构造函数，如果不适用需要自己写清楚\n```cpp\nDerived::Derived(...) : Base() {...};  //Base()是编译器帮我们加的 不适用就自己主动写\n析构过程 先外部子类 后内部父类  (层层剥开)\nDerived::~Derived(...){... ~Base()};   //~Base() 是编译器帮我们加的\n```\n\n如果类会成为父类，析构函数必须是virtual，否则会出现undefined behavior\n\n\n## P12 虚函数 virtual functions\n\nnon-virtual **非虚函数**：不希望子类(derived class)重新定义(override, 覆写)\n\nvirtual       **虚函数**：  希望子类(derived class)重新定义(override, 覆写)，即使它已有默认定义。\n\npure virtual  **纯虚函数**：  希望子类(derived class)重新定义(override, 覆写)，它一定没有默认定义\n\n子函数使用override重写定义 \n```cpp  \nclass Shape{\npublic:\n    virtual void draw() const = 0;                 //纯虚函数  子函数一定要重写\n    virtual void error(const std::string& msg);    //虚函数\n    int objectID() const;                          //非虚函数\n    ...\n};\nclass Rectangle: public Shape{...};\nclass Ellipse.public Shape {...};\n```\n\n设计模式：Template Method\n较为有名的应用MFC\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass CDocument\n{\npublic:\n    void OnFileOpen()\n    {\n        cout << \"open file...\" << endl;\n        Serialize();\n        cout << \"close file...\" << endl;\n    }\n    virtual void Serialize() {};\n};\nclass CMyDoc : public CDocument\n{\npublic:\n    //只有应用程序本身知道如何读取自己的文件（格式）\n    virtual void Serialize()\n    {\n        cout << \"CMyDoc::Serial()\" << endl;\n    }\n}\nint main()\n{\n    CMyDoc myDoc;\n    myDoc.OnFileOpen();\n}\n```\n\n委托 + 继承\n\n设计模式Observer\n列表存放需要被更新的目标，提供订阅 退订 和 遍历功能\n父类提供更新虚函数，由子类继承实现需要被更新的操作\n多用于UI更新\n\n委托 + 继承\n\n设计模式Composite\n文件系统 既有文件 也有目录 目录里面还有文件和目录\n\n委托 + 继承\n\n设计模式Prototype 原型\n创建一个未来别人定义的类\n\n\n## P14\n\nC++技术主线\n\n面向对象编程 和 泛型编程(模板)\n\nSTL标准库基本都是模板编程，泛型思维，继承关系很少\n书籍推荐\n\n## P15\n\n转换函数 conversion function\n```cpp\nclass Fraction   //分数\n{\npublic:\n    Fraction(int num, int den = 1);\n     : m_numeratior(num), m_denominator(den) {}\n    operator double() const {\n      return (double)(m_numerator / m_denmoinator);\n    }\nprivate:\n    int m_numerator;    //分子\n    int m_denominator;  //分母\n};\n```\n\n应用：\n```cpp\nFraction f(3, 5);\ndouble d = 4+f;  //调用operator double() 将f 转为0.6\n```","tags":["CPP"]},{"title":"一主机多客户端websocket通讯","url":"/2024/08/25/一主机多客户端websocket通讯/","content":"\nuvicorn FastAPI WebSocket\n\n## 1.概述\n\nwebsocket服务器，接收多个客户端连接。接收客户端的数据经由算法处理后，将结果返回给对应客户端。\n\nfastapi同时支持http协议，可自行增加可提供网页服务。\n\n\n## 2.程序文件\n\n自行准备一张jpg格式的图片，复制到程序文件夹中，并重命名为`picture_in.jpg`\n\n将以下代码存储为对应名称的文件，并全部放到程序文件夹中\n\n```python\n# pyqt_app.py\nimport sys\nimport cv2\nfrom PyQt5.QtCore import Qt\nfrom PyQt5.QtCore import QThread\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel\nfrom web_api import WebTask, ProcessingTask\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"FastAPI + PyQt\")\n\n        # 创建一个垂直布局\n        layout = QVBoxLayout()\n\n        # 创建一个标签并添加到布局中\n        self.label = QLabel()\n        layout.addWidget(self.label)\n\n        self.lab_img = QLabel()\n        layout.addWidget(self.lab_img)\n\n        # 创建一个 widget 并设置布局\n        central_widget = QWidget()\n        central_widget.setLayout(layout)\n        self.setCentralWidget(central_widget)\n\n    def change_txt(self, msg):\n        self.label.setText(msg)\n\n    def display_img(self, id, num, im):\n        print(f'socket:{id}, image:{num}')\n        cv2.imshow('im', im)\n        cv2.waitKey(1)\n\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = MainWindow()\n    window.show()\n\n    # Web\n    webThread = QThread()\n    web = WebTask()\n    web.moveToThread(webThread)\n    webThread.started.connect(web.long_running)\n    web.signal_text.connect(window.change_txt)\n    # web.signal_client_msg.connect(window.display_img)\n\n    # Processing\n    procThread = QThread()\n    proc = ProcessingTask()\n    proc.moveToThread(procThread)\n    procThread.started.connect(proc.long_running)\n    # web.signal_client_msg.connect(proc.receive_msg, Qt.DirectConnection)\n\n    webThread.start()\n    procThread.start()\n\n    sys.exit(app.exec_())\n\n```\n\n\n```python\n# web_api.py\nimport base64\nimport asyncio\nimport threading\nimport time\nimport cv2\nimport numpy as np\nimport uvicorn\nfrom io import BytesIO\nfrom typing import List\nfrom PIL import Image\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom PyQt5.QtCore import QObject, pyqtSignal\nfrom collections import deque\nfrom IDQueue import IDQueue\n\nmax_len_queue = 5\nsocket_to_ai_queue = deque(maxlen=max_len_queue)\nai_to_socket_queue = IDQueue()\nsocket_to_ai_lock = threading.Lock()\nai_to_socket_lock = threading.Lock()\n\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def send_personal_message(self, message: str, websocket: WebSocket):\n        await websocket.send_text(message)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\n\nclass WebTask(QObject):\n    signal_text = pyqtSignal(str)\n    signal_client_msg = pyqtSignal(int, int, np.ndarray)\n\n    def __init__(self):\n        super().__init__()\n        self.app = FastAPI()\n        self.manager = ConnectionManager()\n\n    def long_running(self):\n        @self.app.websocket(\"/ws_bytes/{client_id}\")\n        async def websocket_client_msg(websocket: WebSocket, client_id: int):\n            await self.manager.connect(websocket)\n            ai_to_socket_queue.clear(client_id)\n            try:\n                while True:\n                    data = await websocket.receive_json()\n                    images = data.get(\"images\", {})\n                    img_b64 = images.get(\"encoded\", \"\")\n                    img_id_send = images.get(\"image_id\", -1)\n                    if len(img_b64) > 0:\n                        img_file = BytesIO(base64.b64decode(img_b64))\n                        # 方式一  Image\n                        # im = Image.open(img_file)\n                        # im.save('picture_out.jpg', \"JPEG\")\n                        # 方式二  cv2\n                        img_array = np.frombuffer(img_file.getvalue(), dtype=np.uint8)\n                        im = cv2.imdecode(img_array, cv2.IMREAD_COLOR)\n                        # cv2.imshow('im', im)\n                        # cv2.waitKey(1)\n                        # cv2.destroyAllWindows()\n                        # self.signal_client_msg.emit(client_id, img_id, im)\n\n                        # 发送给处理线程\n                        if len(socket_to_ai_queue) < max_len_queue:\n                            with socket_to_ai_lock:\n                                print(\"socket_to_ai_queue append\")\n                                socket_to_ai_queue.append((client_id, img_id_send, im))\n                        else:\n                            print(\"socket_to_ai_queue full\")\n                        # 从处理线程接收结果\n                        timeout = 1000  # 超时时长 1000*0.003=3秒\n                        while timeout:\n                            timeout -= 1\n                            if ai_to_socket_queue.len(client_id):\n                                with ai_to_socket_lock:\n                                    print(\"ai_to_socket_queue pop\")\n                                    img_id_read, count = ai_to_socket_queue.pop(client_id)\n                                    if img_id_send == img_id_read:\n                                        break\n                                    else:\n                                        print(f\"img_id_send:{img_id_send} != img_id_read:{img_id_read}\")\n                            else:\n                                await asyncio.sleep(0.003)\n\n                    await self.manager.send_personal_message(f\"You client_id:{client_id}, img_id:{img_id_send}, count:{count}\", websocket)\n            except WebSocketDisconnect:\n                self.manager.disconnect(websocket)\n\n        # 启动 Uvicorn 服务器\n        asyncio.create_task(uvicorn.run(self.app, host=\"0.0.0.0\", port=8000))\n\n\nclass ProcessingTask(QObject):\n    def __init__(self):\n        super().__init__()\n\n    def work(self):\n        print(\"work start\")\n        time.sleep(0.1)\n        print(\"work finsh\")\n\n    def send_result(self, client_id, val):\n        if ai_to_socket_queue.len(client_id) < max_len_queue:\n            with ai_to_socket_lock:\n                print(\"ai_to_socket_queue append\")\n                ai_to_socket_queue.add(client_id, val)\n        else:\n            print(\"ai_to_socket_queue full\")\n\n    def long_running(self):\n        count = 0\n        print(f'ProcessingTask running')\n        while True:\n            if len(socket_to_ai_queue) > 0:\n                with socket_to_ai_lock:\n                    print(\"socket_to_ai_lock popleft\")\n                    client_id, img_id, im = socket_to_ai_queue.popleft()\n                print(f\"thread count:{count}\")\n                count += 1\n                self.work()\n                self.send_result(client_id, (img_id, count))\n            else:\n                time.sleep(0.003)\n\n```\n\n```python\n# IDQueue.py\nfrom collections import OrderedDict, deque\n\nclass IDQueue:\n    def __init__(self):\n        self.queue_dict = OrderedDict()\n        self.queue_lengths = {}\n\n    def add(self, id, item):\n        if id not in self.queue_dict:\n            self.queue_dict[id] = deque()\n            self.queue_lengths[id] = 0\n        self.queue_dict[id].append(item)\n        self.queue_lengths[id] += 1\n        self.queue_dict.move_to_end(id)\n\n    def pop(self, id):\n        if id not in self.queue_dict or not self.queue_dict[id]:\n            return None\n        item = self.queue_dict[id].popleft()\n        self.queue_lengths[id] -= 1\n        if self.queue_lengths[id] == 0:\n            del self.queue_dict[id]\n            del self.queue_lengths[id]\n        return item\n\n    def len(self, id):\n        return self.queue_lengths.get(id, 0)\n\n    def get_queue(self, id):\n        return self.queue_dict.get(id, None)\n\n    def clear(self, id):\n        print(f\"IDQueue {id} clear\")\n        if id in self.queue_dict:\n            del self.queue_dict[id]\n            del self.queue_lengths[id]\n\n\nqueue = IDQueue()\n\n# 添加元素\nqueue.add(1, 'apple')\nqueue.add(1, 'banana')\nqueue.add(2, 'cherry')\nqueue.add(2, 'date')\n\n# 获取队列长度\nprint(queue.len(1))  # Output: 2\nprint(queue.len(2))  # Output: 2\n\n# 弹出元素\nprint(queue.pop(1))  # Output: 'apple'\nprint(queue.pop(2))  # Output: 'cherry'\n\n# 获取队列\nprint(list(queue.get_queue(1)))  # Output: ['banana']\nprint(list(queue.get_queue(2)))  # Output: ['date']\n\n```\n\n```python\n# fastapi_websockets_client1.py\nimport asyncio\nimport base64, json\nimport time\nimport websockets\n\nlast_time = time.time()\nlast_step = 0\n\n\ndef ptime():\n    global last_time, last_step\n    now = time.time()\n    print(f\"step{last_step}: {now - last_time}s    now: {now}\")\n    last_time = now\n    last_step += 1\n\n\nasync def send_image(client_id, filename):\n    async with websockets.connect(f'ws://127.0.0.1:8000/ws_bytes/{client_id}') as websocket:\n        # 替换为你的图片文件路径\n        for i in range(0, 20):\n            with open(filename, 'rb') as imgfile:\n                base64_bytes = base64.b64encode(imgfile.read())\n                base64_encoded = base64_bytes.decode()\n            data = {\n                'hard_info': {\n                    'num': 1,\n                    \"name\": \"1号工位\",\n                    'ip': \"192.168.0.10\"\n                },\n                'images': {\n                        'camera_index': 1,\n                        'image_id': i,\n                        'encoded': base64_encoded\n                }\n            }\n            print(f\"start{i}\")\n            await websocket.send(json.dumps(data))\n            response = await websocket.recv()\n            print(response)\n            ptime()\n\n\n# 替换为你想要使用的客户端 ID\nclient_id = 1\nimg_path = 'picture_in.jpg'\nasyncio.get_event_loop().run_until_complete(send_image(client_id, img_path))\n```\n\n\n## 3.服务器端说明\n\n文件： pyqt_app.py  web_api.py  IDQueue.py\n\n\n主线程：  PyQt界面\n子线程1：  **WebTask**  uvicorn + fastapi\n子线程2 ： **ProcessingTask**  算法\n\n\n数据流一：从websocket到计算线程\n```\nwebsocket1       ---\nwebsocket2       ---==== 队列 ====    计算线程\nwebsocket3       ---\n```\n\n数据流二：从计算线程到websocket\n```\n                                          ---    websocket1\n计算线程  ==== IDQueue 带socket Id的队列 ====---    websocket2\n                                          ---    websocket3\n```\n\n\n## 4.客户端\n\nfastapi_websockets_client.py\n\n多复制几份，修改`client_id = 1`为其他数字。\n\n## 5.测试\n\n1号终端运行\n\n```bash\npython  pyqt_app.py\n```\n\n1号终端运行服务器\n\n```bash\npython  pyqt_app.py\n```\n\n2号终端运行客户端1\n\n```bash\npython  fastapi_websockets_client1.py\n```\n\n3号终端运行客户端2\n\n```bash\npython  fastapi_websockets_client2.py\n```\n\n客户端日志\n\n![client_log.png](client_log.png)","tags":["Python"]},{"title":"PyQt创建线程的三种方式","url":"/2024/08/25/PyQt创建线程的三种方式/","content":"\n参考链接 [stackoverflow](https://stackoverflow.com/questions/6783194/background-thread-with-qthread-in-pyqt)\n\n```python\nimport sys\nimport time\n\nfrom PyQt5.QtCore import (QCoreApplication, QObject, QRunnable, QThread,\n                          QThreadPool, pyqtSignal)\n\n\n# Subclassing QThread\n# http://qt-project.org/doc/latest/qthread.html\nclass AThread(QThread):\n\n    def run(self):\n        count = 0\n        while count < 5:\n            time.sleep(1)\n            print(\"A Increasing\")\n            count += 1\n\n# Subclassing QObject and using moveToThread\n# http://blog.qt.digia.com/blog/2007/07/05/qthreads-no-longer-abstract\nclass SomeObject(QObject):\n\n    finished = pyqtSignal()\n\n    def long_running(self):\n        count = 0\n        while count < 5:\n            time.sleep(1)\n            print(\"B Increasing\")\n            count += 1\n        self.finished.emit()\n\n# Using a QRunnable\n# http://qt-project.org/doc/latest/qthreadpool.html\n# Note that a QRunnable isn't a subclass of QObject and therefore does\n# not provide signals and slots.\nclass Runnable(QRunnable):\n\n    def run(self):\n        count = 0\n        app = QCoreApplication.instance()\n        while count < 5:\n            print(\"C Increasing\")\n            time.sleep(1)\n            count += 1\n        app.quit()\n\n\ndef using_q_thread():\n    app = QCoreApplication([])\n    thread = AThread()\n    thread.finished.connect(app.exit)\n    thread.start()\n    sys.exit(app.exec_())\n\ndef using_move_to_thread():\n    app = QCoreApplication([])\n    objThread = QThread()\n    obj = SomeObject()\n    obj.moveToThread(objThread)\n    obj.finished.connect(objThread.quit)\n    objThread.started.connect(obj.long_running)\n    objThread.finished.connect(app.exit)\n    objThread.start()\n    sys.exit(app.exec_())\n\ndef using_q_runnable():\n    app = QCoreApplication([])\n    runnable = Runnable()\n    QThreadPool.globalInstance().start(runnable)\n    sys.exit(app.exec_())\n\nif __name__ == \"__main__\":\n    # using_q_thread()\n    using_move_to_thread()\n    # using_q_runnable()\n\n```","tags":["PyQt"]},{"title":"Jetson安装USB转RS232串口驱动","url":"/2024/07/03/Jetson安装USB转RS232串口驱动/","content":"\nUSB转串口芯片使用 **pl2303**\n\n## 1.环境\n\n硬件:\n\n* jetson nano\n* USB转RS232\n\n串口调试软件：\n\n带ui类：cutecom、putty\n\n命令行：minicom、screen\n\n先用调试软件测试，系统自带的驱动有问题再进行下面的操作。\n\n## 2.我遇到的问题\n\n先用的usb转RS232，芯片试CH340，出现的问题是：波特率115200，windows中收到的数据正常。Jetson收到的数量差不多，但数据全部错误。收发如下：\n\n![jetson_ch340_error](jetson_ch340_error.jpeg)\n\n发送'1'接收0x11。随后再WCH沁恒官网下驱动，编译替换。调试助手测试正常，但接到实际设备上使用数据还是乱码，遂放弃使用。\n\n换PL2303，windows需要等一会才能自动安装驱动。而jetson不能正常挂载到ttyUSBx。`dmesg`查看只能到usb 1-2.1: SerialNumber: CMCVe12CJ06，重新编译和替换驱动后，显示attached到ttyUSB0，通过putty查看设备数据，接收正常。\n\n```bash\n[ 1640.374193] usb 1-2.1: new full-speed USB device number 8 using tegra-xusb\n[ 1640.398877] usb 1-2.1: New USB device found, idVendor=067b, idProduct=23a3\n[ 1640.398894] usb 1-2.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[ 1640.398905] usb 1-2.1: Product: USB-Serial Controller\n[ 1640.398914] usb 1-2.1: Manufacturer: Prolific Technology Inc.\n[ 1640.398923] usb 1-2.1: SerialNumber: CMCVe12CJ06\n[ 3483.947952] usbserial: USB Serial deregistering driver pl2303\n[ 3483.948103] usbcore: deregistering interface driver pl2303\n[ 3500.329161] pl2303: loading out-of-tree module taints kernel.\n[ 3500.335716] usbcore: registered new interface driver pl2303\n[ 3500.335756] usbserial: USB Serial support registered for pl2303\n[ 3500.335830] pl2303 1-2.1:1.0: pl2303 converter detected\n[ 3500.336221] usb 1-2.1: pl2303 converter now attached to ttyUSB0\n```\n\n## 3.基础\n\n`dmesg` 先插拔USB，再使用指令查看系统变化信息\n\n`lsusb` 查看USB接口硬件列表\n\n`ls /dev` 查看硬件设备列表\n\n`sudo lsusb -v -d 067b:23a3` 查看某个具体设备的详细信息\n\n`lsmod`  显示已载入系统的模块 \n\n`sudo rmmod pl2303` 卸载模块\n\n`insmod` 一次只能加载特定的一个设备驱动，且需要驱动的具体地址。写法为：\n\n```bash\ninsmod drv.ko\n```\n\n`modprobe` 则可以一次将有依赖关系的驱动全部加载到内核。不加驱动的具体地址，但需要在安装文件系统时是按照make modues_install的方式安装驱动模块的。驱动被安装在/lib/modules/$(uname -r)/...下。写法为：\n\n```bash\nmodprob drv\n```\n\nmodprobe 和insmod一样都是用来加载内核module的不过modprobe比较智能，它可以根据module的依赖性来自动为你加载；而insmod就做不到这点\n\n\n\n## 4.下载驱动\n\n从 [UGREEN绿联](https://www.lulian.cn/download/tag/pl2303qudong) 网下载驱动，并解压。内容如下：\n\n![pl2303_driver](pl2303_driver.png)\n\n## 5.查看jetson内核版本\n\n```bash\nuname -a\n```\n\n可以看到 4.9.337\n\n```bash\nLinux booster 4.9.337-tegra #1 SMP PREEMPT Thu Jun 8 21:19:14 PDT 2023 aarch64 aarch64 aarch64 GNU/Linux\n```\n\n## 6.将驱动上传到Jetson\n\n从PL2303G_Linux_Driver_v1.0.6中可以看到有两个4.9版的，选一个（失败了再试另一个）使用MobaXterm或其他软件上传到jetson。\n\n## 7.编译安装\n\n```bash\ncd 4.9_ok\nmake\n```\n\n可以看到成功编译出pl2303.ko文件\n\n接下来卸载旧的，再安装新编译的。\n\n```bash\nsudo rmmod pl2303\nsudo insmod pl2303.ko\n```\n\ndmesg | tail 查看是否attach到ttyUSBx\n\n`usb 1-2.1: pl2303 converter now attached to ttyUSB0`\n\n## 8.测试\n\n```bash\nsudo putty\n```\n\n设置波特率，刚开始可以将RS232的Tx和Rx引脚短接，键盘按什么屏幕显示什么说明通信正常。\n\n替换自带驱动\n\n```bash\nsudo cp pl2303.ko /lib/modules/4.9.337-tegra/kernel/drivers/usb/serial/\n```\n\n\n\n## 9.修改权限免ROOT\n\n参考[github](https://github.com/Slamtec/rplidar_ros/blob/ros2/scripts/create_udev_rules.sh)\n\n以rplidar.rules为模板，修改idVendor和idProduct的值，如下：\n\n```bash\nKERNEL==\"ttyUSB*\", ATTRS{idVendor}==\"067b\", ATTRS{idProduct}==\"23a3\", MODE:=\"0777\", SYMLINK+=\"mygps\"\n```\n\n启用规则\n\n```bash\nsudo service udev reload\nsudo service udev restart\nsudo udevadm control --reload && sudo udevadm trigger\n```\n\n查看规则是否应用成功\n\n```bash\nll /dev\nlrwxrwxrwx   1 root root           7 7月   2 14:06 mygps -> ttyUSB0\n```\n\n测试\n\n```bash\nputty\n```\n\n重启，如果不能正常挂载，需要使用下面的指令：\n\n```bash\nmodprobe\n```\n","tags":["Jetson"]},{"title":"ros2基础教程","url":"/2024/07/03/ros2基础教程/","content":"\n## 1.基础知识\n### 1.1工作空间\n\n* 创建工作空间\n\n  一个存放项目开发相关文件的文件夹，也是开发过程中存放所有资料的大本营。 \n\n```bash\n# 选择一个存储的目录，也可以放在根目录\ncd ~/yahboomcar_ros2_ws\n# 创建工作的空间\nmkdir -p yahboomcar_ws/src\ncd yahboomcar_ws\n```\n\n* 编译\n\n```bash\ncolcon build\n```\n\n* 设置环境变量\n\n```bash\n# 仅在当前终端生效\nsource install/setup.bash   \n# 所有终端均生效\necho \"source ~/yahboomcar_ros2_ws/yahboomcar_ws/install/setup.bash\" >> ~/.bashrc    \n```\n\n\n\n### 1.2功能包\n\n 把不同功能的代码划分到不同的功能包中，尽量降低他们之间的耦合关系 \n\n* 创建c++功能包\n\n```bash\ncd ~/yahboomcar_ros2_ws/yahboomcar_ws/src\n# 创建C++功能包\nros2 pkg create pkg_helloworld_cpp --build-type ament_cmake --dependencies rclcpp --node-name helloworld  \n```\n\n* 创建python功能包\n\n```bash\ncd ~/yahboomcar_ros2_ws/yahboomcar_ws/src\nros2 pkg create pkg_helloworld_py --build-type ament_python --dependencies rclpy --node-name helloworld\n```\n\n* 目录结构\n\n```bash\nWorkSpace --- 自定义的工作空间。\n    |--- build：存储中间文件的目录，该目录下会为每一个功能包创建一个单独子目录。\n    |--- install：安装目录，该目录下会为每一个功能包创建一个单独子目录。\n    |--- log：日志目录，用于存储日志文件。\n    |--- src：用于存储功能包源码的目录。\n        |-- C++功能包\n            |-- package.xml：包信息，比如:包名、版本、作者、依赖项。\n            |-- CMakeLists.txt：配置编译规则，比如源文件、依赖项、目标文件。\n            |-- src：C++源文件目录。\n            |-- include：头文件目录。\n            |-- msg：消息接口文件目录。\n            |-- srv：服务接口文件目录。\n            |-- action：动作接口文件目录。\n        |-- Python功能包\n            |-- package.xml：包信息，比如:包名、版本、作者、依赖项。\n            |-- setup.py：与C++功能包的CMakeLists.txt类似。\n            |-- setup.cfg：功能包基本配置文件。\n            |-- resource：资源目录。\n            |-- test：存储测试相关文件。\n            |-- 功能包同名目录：Python源文件目录。\n```\n\n* 其他文件\n\n```bash\n|-- C++或Python功能包\n    |-- launch：存储launch文件。\n    |-- rviz：存储rviz2配置相关文件。\n    |-- urdf：存储机器人建模文件。\n    |-- params：存储参数文件。\n    |-- world：存储仿真环境相关文件。\n    |-- map：存储导航所需地图文件。\n    |-- ......\n```\n\n\n\n### 1.3节点\n\n 每个节点都对应某一单一的功能模块  (例如：雷达驱动节点可能负责发布雷达消息，摄像头驱动节点可能负责发布图像消息) \n\n 一个完整的机器人系统可能由许多协同工作的节点组成，ROS2中的单个可执行文件(C++程序或Python程序)可以包含一个或多个节点。 \n\n 在通信时，不论采用何种方式，通信对象的构建都依赖于节点(Node) \n\n`pkg_helloworld_py/helloworld.py` 来编写节点功能\n\n\n\nsetup.py 定义口入点\n\n```python\nentry_points = {\n\t'console_scripts':[\n        # 入口函数名\n        'helloworld = pkg_helloworld_py.helloworld:main'\n        # 可执行文件名      功能包名称      编写节点功能的python文件名称\n    ],\n},\n```\n\n* 只编译特定功能包\n\n```bash\ncd ~/yahboomcar_ros2_ws/yahboomcar_ws\ncolcon build --packages-select pkg_helloworld_py\nsource install/setup.bash\n```\n\n* 启动单个节点\n\n```bash\nros2 run pkg_helloworld_py helloworld\n```\n\n* 启动多个节点\n\n```bash\n# 示例为其他项目\nros2 launch rplidar_ros rplidar_s2_lanuch.py\n```\n\n\n\n## 2.激光雷达\n\n### 2.1发布雷达扫描数据\n\n* 进入工作空间 `cd ~/ros2_ws/src`\n\n* 拉取项目代码\n\n```bash\ngit clone -b ros2 https://github.com/Slamtec/rplidar_ros.git\n```\n\n接下来的操作可以查看项目中的README.md文件。注意运行测试时需要增加串口端口设置 ：`serial_port:=/dev/rplidar`\n\n* 不带界面\n\n```bash\nros2 run rplidar_ros rplidar_node serial_port:=/dev/rplidar\n```\n\n或\n\n```bash\nros2 launch rplidar_ros rplidar_s2_launch.py serial_port:=/dev/rplidar\n```\n\n* 带界面\n\n```bash\nros2 launch rplidar_ros view_rplidar_s2_launch.py serial_port:=/dev/rplidar\n```\n\n\n\n### 2.2订阅雷达数据并判断最小距离\n\n* 创建python功能包\n\n```bash\ncd ~/ros2_ws/src\nros2 pkg create rplidar_warning --build-type ament_python --dependencies rclpy --node-name rplidar_warning\n```\n\n* 修改文件内容实现订阅及最小距离判断功能\n\n~/ros2_ws/src/rplidar_warning/rplidar_warning/rplidar_warning.py\n\n```python\n#!/usr/bin/env python\n# coding:utf-8\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import Bool\nimport numpy as np\nimport math\nRAD2DEG = 180 / math.pi\n\nclass laserWarning(Node):\n    def __init__(self,name):\n        super().__init__(name)\n\n        self.Buzzer_state = False\n        self.laserAngle = 70\n        self.ResponseDist = 0.5\n        self.pub_Buzzer = self.create_publisher(Bool, '/Buzzer', 1)\n        self.sub_laser = self.create_subscription(LaserScan, '/scan', self.laserCallback, 1000)\n\n    def laserCallback(self, scan_data):\n        if not isinstance(scan_data, LaserScan): return\n        # 记录激光扫描并发布最近物体的位置（或指向某点）\n        # Record the laser scan and publish the position of the nearest object (or point to a point)\n        ranges = np.array(scan_data.ranges)\n        # 创建距离列表，将检测范围内的有效距离放入列表中\n        # create distance list, put the effective distance within the detection range into the list\n        minDistList = []\n        # 创建序列号，将有效距离对应的ID放入列表中\n        # Create a serial number and place the ID corresponding to the valid distance in the list\n        minDistIDList = []\n        # 按距离排序以检查从较近的点到较远的点是否是真实的东西\n        # if we already have a last scan to compare to:\n        for i in range(len(ranges)):\n            angle = (scan_data.angle_min + scan_data.angle_increment * i) * RAD2DEG\n            # if angle > 90: print \"i: {},angle: {},dist: {}\".format(i, angle, scan_data.ranges[i])\n            # 通过清除不需要的扇区的数据来保留有效的数据\n            if abs(angle) > (180 - self.laserAngle):\n                minDistList.append(ranges[i])\n                minDistIDList.append(angle)\n        if len(minDistList) == 0: return\n        # 找到最小距离\n        # Find the minimum distance\n        minDist = min(minDistList)\n        # 找到最小距离对应的ID\n        # Find the ID corresponding to the minimum distance\n        minDistID = minDistIDList[minDistList.index(minDist)]\n        self.get_logger().info(f\"find minimum {minDist} {minDistID}\")\n\n        if minDist <= self.ResponseDist:\n            if self.Buzzer_state == False:\n                b = Bool()\n                b.data = True\n                self.pub_Buzzer.publish(b)\n                self.Buzzer_state = True\n        else:\n            if self.Buzzer_state == True:\n                self.pub_Buzzer.publish(Bool())\n                self.Buzzer_state = False\n\n\n    def dynamic_reconfigure_callback(self, config, level):\n        self.laserAngle = config['laserAngle']\n        self.ResponseDist = config['ResponseDist']\n        return config\n\n\ndef main():\n    rclpy.init()\n    tracker = laserWarning(\"laser_Warning\")\n    rclpy.spin(tracker)\n    tracker.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n```\n\n\n\n* 删除 build install log 文件夹\n\n```bash\nrm -rf build install log\n```\n\n* 编译所有功能包\n\n```bash\ncolcon build\n```\n\n* 编译选中的功能包(选择使用)\n\n```bash\ncolcon build --packages-select pkg_helloworld_py\n```\n\n* 开启两个终端，并且都更新一次环境变量\n\n```bash\nsource install/setup.bash\n```\n\n* 终端1发布雷达数据\n\n```bash\nros2 launch rplidar_ros view_rplidar_s2_launch.py serial_port:=/dev/rplidar\n```\n\n* 终端2订阅雷达数据\n\n```bash\nros2 run rplidar_warning rplidar_warning\n```\n","tags":["ROS2"]},{"title":"在docker中运行ROS2容器并测试思岚激光雷达","url":"/2024/07/03/在docker中运行ROS2容器并测试思岚激光雷达/","content":"\n## 1.docker安装及基础知识\n\n[docker安装](https://www.yahboom.com/build.html?id=7178&cid=586)\n\n[国内镜像站点]( https://linux.do/t/topic/114516)\n\n[yahboomtechnology/ros2-base镜像](https://hub.docker.com/r/yahboomtechnology/ros2-base/tags)\n\n[导出镜像并压缩、解压并导入镜像](https://blog.csdn.net/qq_34777982/article/details/102454739)\n\n[创建容器 硬件挂载 GUI显示](https://www.yahboom.com/build.html?id=7182&cid=586)  脚本用来创建容器，仅需运行一次。后期使用docker start/stop开控制容器启停\n\n[在docker中使用GPIO](https://github.com/NVIDIA/jetson-gpio/tree/master) `--privileged \\` 此选项使docker镜像使用所有宿主机的硬件\n\n建立[udev规则](https://github.com/Slamtec/rplidar_ros/blob/ros2/scripts/rplidar.rules)(将指定ttyUSB映射为rplidar并修改[使用权限](https://www.small09.top/posts/210311-serialmodeandudevinlinux/))\n\n```bash\n~$ ls -al /dev/ttyUSB0 /dev/rplidar \nlrwxrwxrwx 1 root root         7 6月  25 09:14 /dev/rplidar -> ttyUSB0\ncrwxrwxrwx 1 root dialout 188, 0 6月  25 09:14 /dev/ttyUSB0\n```\n\n创建docker的脚本 create.sh  此方式不会将ttyUSB0 映射为rplidar，也不需要在ros2中指定串口\n\n```bash\n!/bin/bash\nxhost +\n\ndocker container run -it \\\n--net=host \\\n--env=\"DISPLAY\" \\\n--env=\"QT_X11_NO_MITSHM=1\" \\\n--privileged \\\n-v /tmp/.X11-unix:/tmp/.X11-unix \\\n-v /home/zy/Code:/root/yahboomcar_ros2_ws/temp \\\n-p 9090:9090 \\\n-p 8888:8888 \\\nyahboomtechnology/ros2-base:2.0.2 /bin/bash\n```\n\n## 2.常用指令\n\n```bash\ndocker可以使用界面。每次重启后必须要在VNC远程桌面中打开的Terminal后执行下面这段指令，开启GUI访问权限，再启动容器。\nxhost +local:root\n或\nxhost +\n\n查看容器运行情况\ndocker ps -a\n\n运行容器\ndocker run 后面加一堆参数 包含镜像名称和容器标签\n\n启动容器  运行过一次后面仅需使用管理容器指令\ndocker start [ID或标签]\ndocker stop\ndocker rm\n\n再次进入容器\ndocker attach [ID或标签]\n新建shell进入容器\ndocker exec -it [容器id] /bin/bash\n\nexit        # 容器停止退出\nctrl+P+Q    # 容器不停止退出\n\n运行软件，查看能否开启GUI画面\nrviz2\n```\n\n\n\n## 3.进入docker\n\n[ROS2示例测试](https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ros2_2) 只按ROS2示例测试小节测试docker环境的的ROS2是否运行正常\n\n\n\n拉取思岚雷达在ROS2中应用的[git仓库](https://github.com/Slamtec/rplidar_ros/tree/ros2)，切换到ros2分枝。按README.md说明建立和编译项目。\n\n```bash\ngit clone -b ros2 https://github.com/Slamtec/rplidar_ros.git\n```\n\n注意：\n\n项目默认使用 /dev/ttyUSB0 ，然而我们在建立docker容器时将宿主机的ttyUSB0最终映射为docker中的rplidar\n\n故此时在docker中执行\n\n```bash\n~$ ls /dev\nconsole  fd  full  mqueue  null ptmx  pts  random  rplidar  shm  stderr  stdin  stdout  tty  urandom  zero\n```\n\n发现是没有ttyUSB0的。\n\n\n\nREADME.md中的运行指令\n\n```bash\nros2 launch rplidar_ros view_rplidar_s2_launch.py\n```\n\n需要指定串口号\n\n\n```bash\nros2 launch rplidar_ros view_rplidar_s2_launch.py serial_port:=/dev/rplidar\n```","tags":["ROS2"]},{"title":"jetson刷机救砖","url":"/2024/07/03/jetson刷机救砖/","content":"\n## 1.烧录EMMC引导\n\n如果开机不显示Nvidia的绿色图片，说明引导固件损坏。虽然sd卡或U盘中有系统，但硬件并不知道要去何处加载。现象为开机指示绿灯亮，但HDMI无显示，USB接口无供电（鼠标不亮）。通过TTL串口可以看到机器不停的重启。\n\n[亚博教程](https://www.yahboom.com/public/upload/upload-html/1710831903/JetsonNano%E7%83%A7%E5%BD%95%E7%B3%BB%E7%BB%9F.html) 中的刷机的指令我在jetson nano上尝试失败。\n\n[NVIDIA SDK Manager](https://docs.nvidia.com/sdk-manager/system-requirements/index.html) 打开链接查看刷写jetson需要的宿主机系统要求，如 Jetson nano 需要 Ubuntu 1804.\n\n下载 [SDK Manager](http://docs.nvidia.com/sdk-manager/download-run-sdkm/index.html) 此软件可下载需要刷机的工具和软件包。\n\n建议使用物理机，虚拟机Oracle VM VirtualBox出现将USB分配给虚拟机，但通过界面写入的时候会出现USB短线的问题。\n\n也可以在界面刷写失败后尝试使用命令行的方式，需要在SDK Manager下载软件包中执行，可参考上面的亚博教程。\n\nhttps://forums.developer.nvidia.com/t/recover-bootloader-in-nano-4g-b01/277975/4\n\n```bash\nsudo ./flash.sh jetson-nano-qspi mmcblk1p1\n```\n\n将跳线帽连接到FC REC和GND引脚， 接入电源，最后和插入microUSB数据线。\n\n上电开机后会自动进入REC刷机模式。 \n\n使用Ubuntu刷机\n\n\n## 2.烧录系统镜像\n\n下载[img系统镜像](https://developer.nvidia.com/embedded/downloads#?tx=$product,jetson_nano) ，选择链接中的 SD Card Image。\n\n烧录过程参考上一小节的亚博教程\n\n\n\n## 3.SD卡扩容\n\n```bash\nsudo apt install gparted\n```\n\n在图形界面环境下操作。\n\n\n\n## 4.SSH远程登录\n\n[参考链接](https://linuxize.com/post/how-to-enable-ssh-on-ubuntu-18-04)\n\n\n\n## 5.VNC远程桌面\n\n[亚博智能](https://www.yahboom.com/build.html?id=6189&cid=586)\n\n\n\n## 6.Jtop的安装和使用\n\n[参考](https://jetsonhacks.com/2023/02/07/jtop-the-ultimate-tool-for-monitoring-nvidia-jetson-devices)\n\n\n","tags":["Jetson"]},{"title":"Ubuntu-RSP1-GNURadio","url":"/2024/05/05/Ubuntu-RSP1-GNURadio/","content":"\nMSI2500 MSI001 RSP1 SoapySDR libmirisdr gr-osmosdr GNURadio Ubuntu\n\n## 1.概述\n\n国内版克隆版RSP1在RTL-433和GNU Radio中的使用\n\n### windows:\n\n使用 [SDRuno](https://www.sdrplay.com/softwarehome/) 软件安装简单易上手.  (建议关闭或卸载流氓杀毒软件)\n\n### Ubuntu: \n\n无法使用 SDRconnec. \n\n按照 [Rev Space](https://revspace.nl/Msi2500SDR) 教程，可将其识别为miri，且能正常采样。\n\n使用方式一： [rtl_433](https://github.com/merbanan/rtl_433)\n\n使用方式二： [GNU Radio](https://www.gnuradio.org/)\n\n对于ubuntu下整个系统框架我是这样理解的：\n\n![Ubuntu_RSP1](Ubuntu_RSP1.png)\n\n\n## 2.Hardware 硬件\n\nBG7YZF 黄淮创客空间\n\na chinese clone of the SDRPlay RSP1.\n\n![taobao](taobao.jpg)\n\n![screenshot_rsp1](Screenshot_rsp1.jpg)\n\nMS001+MSI2500\n\n10k~2GHz ADC:12bit Bandwidth:10MHz TCXO:0.5ppm\n\n![msi001_msi2500](msi001_msi2500.jpg)\n\n## 3.API 驱动\n\nSoapySDR 是另一个开源的SDR硬件抽象层，旨在提供一种通用的API和中间件，用于与不同的SDR硬件设备进行交互。它提供了一个统一的接口，使应用程序能够以一致的方式访问和控制各种SDR设备。SoapySDR 支持多种平台和操作系统，并提供了C++、Python和其他编程语言的绑定。\n\n### 禁用和卸载内核驱动\n\nremove the modules manually\n\n```sh\nsudo modprobe -r msi2500 msi001\n```\n\ncreate a file /etc/modprobe.d/blacklist-msi.conf\n\n```\nblacklist msi001\nblacklist msi2500\n```\n\n### 安装SoapySDR\n\n```sh\nsudo apt install soapysdr-module-mirisdr\n```\n\n### 查找设备\n\n将设备连接到USB接口\n\n```sh\n SoapySDRUtil --find\n ```\n\n回显 result(for example)\n \n```sh\n######################################################\n##     Soapy SDR -- the SDR abstraction library     ##\n######################################################\n\n[INFO] [UHD] linux; GNU C++ version 13.1.0; Boost_107400; UHD_4.4.0.0+ds1-4\nFound device 0\n  default_input = True\n  default_output = True\n  device_id = 0\n  driver = audio\n  label = Built-in Audio\n\nFound device 1\n  driver = miri\n  label = Mirics MSi2500 default (e.g. VTX3D card)\n  miri = 0\n ```\n\nPrint detailed information  打开并打印测试信息\n\n```sh\nSoapySDRUtil  --probe=\"driver=miri\"\n```\n回显 result(for example)\n\n```sh\n######################################################\n##     Soapy SDR -- the SDR abstraction library     ##\n######################################################\n\nProbe device driver=miri\nUsing device #0: Mirics MSi2500 default (e.g. VTX3D card)\n\n----------------------------------------------------\n-- Device identification\n----------------------------------------------------\n  driver=miri\n  hardware=miri\n\n----------------------------------------------------\n-- Peripheral summary\n----------------------------------------------------\n  Channels: 1 Rx, 0 Tx\n  Timestamps: NO\n\n----------------------------------------------------\n-- RX Channel 0\n----------------------------------------------------\n  Full-duplex: NO\n  Supports AGC: NO\n  Stream formats: CF32\n  Native format: CF32 [full-scale=1]\n  Antennas: RX\n  Full gain range: [-1, 49, 1] dB\n    LNA gain range: [-1, 49, 1] dB\n  Full freq range: [0.15, 30], [64, 108], [162, 240], [470, 960], [1450, 1675] MHz\n    RF freq range: [0.15, 30], [64, 108], [162, 240], [470, 960], [1450, 1675] MHz\n    CORR freq range:  MHz\n  Tune args:\n     * LO Offset - Tune the LO with an offset and compensate with the baseband CORDIC.\n       [key=OFFSET, units=Hz, default=0.0, type=float]\n     * CORR - Specify a specific value for this component or IGNORE to skip tuning it.\n       [key=CORR, units=Hz, default=DEFAULT, type=float, options=(DEFAULT, IGNORE)]\n  Sample rates: 8 MSps\n\n_mirisdr_alloc_async_buffers\nLost samples!\n82 01 00 00 00 10 00 00 fb fd bc b4 0e f6 fd fe \nLost samples!\nLost samples!\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n```\n\n## 4.rtl_433\n\nrtl_433 是一个开源的软件项目，用于接收和解码使用软件定义无线电（SDR）接收器（如RTL-SDR）捕获的无线电信号。\n\nrtl_433 项目的目标是支持解码多种不同的无线电设备和协议，包括气象传感器、汽车遥控器、无线温度传感器等。它提供了一个命令行工具，可以直接与RTL-SDR设备进行交互，并将捕获的无线电信号解码为可读的文本输出。\n\n### 安装\n\n```sh\nsudo apt install rtl-433\n```\n\n### 查看设备信息\n\n```sh\nrtl_433 -d driver=miri -v\n```\n\n### 解码测试\n\n```sh\nrtl_433 -d \"miri\"\n```\n\n回显 result(for example)\n\n```sh\nrtl_433 -d \"miri\"\nrtl_433 version 22.11 (2022-11-19) inputs file rtl_tcp RTL-SDR SoapySDR\nUse -h for usage help and see https://triq.org/ for documentation.\nTrying conf file at \"rtl_433.conf\"...\nTrying conf file at \"/home/yourname/.config/rtl_433/rtl_433.conf\"...\nTrying conf file at \"/usr/local/etc/rtl_433/rtl_433.conf\"...\nTrying conf file at \"/etc/rtl_433/rtl_433.conf\"...\nRegistered 191 out of 223 device decoding protocols [ 1-4 8 11-12 15-17 19-23 25-26 29-36 38-60 63 67-71 73-100 102-105 108-116 119 121 124-128 130-149 151-161 163-168 170-175 177-197 199 201-215 217-223 ]\n[INFO] [UHD] linux; GNU C++ version 13.1.0; Boost_107400; UHD_4.4.0.0+ds1-4\n[INFO] Using format CS16.\nSample rate set to 250000 S/s.\nTuner set to automatic gain.\nTuner gain set to Auto.\nTuned to 433.920MHz.\nRtAudio pulse: _NOT_ running realtime scheduling\nbaseband_demod_FM_cs16: low pass filter for 250000 Hz at cutoff 25000 Hz, 40.0 us\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntime      : 2024-05-05 14:15:39\nmodel     : Acurite-986  id        : 4096\nchannel   : 1R           Battery   : 1             temperature: 1.000000 F   status    : 4             Integrity : CRC\n```\n\n##  5.libmirisdr-5\n\nGNU Radio未能通过SoapySDR打开设备，故使用[libmirisdr-5](https://github.com/ericek111/libmirisdr-5)(forked from f4exb/libmirisdr-4)\n\nlibmirisdr 提供了与 Mirics SDR 接收器进行交互的底层驱动程序和API。它允许开发人员通过编程语言（如C/C++）访问和控制 Mirics SDR 接收器的功能。\n\n```sh\ngit clone git@github.com:ericek111/libmirisdr-5.git\n```\n\nbuild and install\n\n```sh\ncd libmirisdr-5\nmkdir build\ncd build\ncmake ..\nmake -j4\nsudo make install\nsudo ldconfig\n```\n\n## 6.gr-osmosdr\n\ngr-osmosdr 是一个与 GNU Radio 软件无线电平台相关的开源项目，用于与各种软件定义无线电（SDR）硬件设备进行交互。\n\n使用 gr-osmosdr，你可以将不同厂商的SDR硬件设备（如RTL-SDR、HackRF、LimeSDR等）与GNU Radio进行集成。它提供了一组模块和函数，用于配置和控制SDR硬件设备的参数，如频率、增益、采样率等。通过这些功能，你可以将SDR硬件设备接收到的无线电信号导入到GNU Radio的流程图中进行进一步的信号处理和分析。\n\n[gr-osmosdr](https://osmocom.org/projects/gr-osmosdr/wiki/GrOsmoSDR)\n\n```sh\ngit clone https://git.osmocom.org/sdr/gr-osmosdr.git\n```\n\nbuild and install\n\n```sh\ncd libmirisdr-5\nmkdir build\ncd build\ncmake ..\nmake -j4\nsudo make install\nsudo ldconfig\n```\n\n\n## 7.GNU Radio\n\nGNU Radio 是一个流程图驱动的开源软件工具包，用于构建软件无线电系统和信号处理应用程序。gr-osmosdr 是 GNU Radio 的一个模块，它提供了与各种SDR硬件设备进行通信的功能。\n\n### 安装\n\n```sh\nsudo apt install gnuradio\n```\n\nopen gnuradio\n\n### 流图1\n\n功能：从sdr读取数据，并现实到界面。如下：\n\n![gnu_project1_grc](gnu_project1_grc.png)\n\nExecute the flow graph\n\n![gnu_project1_run](gnu_project1_run.png)\n\n### 流图2 FM\n\n[YouTube](https://youtu.be/tj_9p_rXULM?si=qtQ6HvAgtN4TNqyG)\n\n功能：从sdr读取数据，使用FM解码，最后从声卡播放。如下：\n\n![gnu_project2_grc](gnu_project2_grc.png)\n\nExecute the flow graph\n\n![gnu_project2_run](gnu_project2_run.png)","tags":["SDR"]},{"title":"Ubuntu-RSP1-RTL_433","url":"/2024/04/21/Ubuntu-RSP1-RTL-433/","content":"\nRSP1 MSI2500 MSI001 SoapySDR RTL_433 Ubuntu\n\n## 建议查看参考链接\n\n[Link !!!](https://revspace.nl/Msi2500SDR)\n\n### 3.1.1. Linux kernel driver\n\nNot sure what the Linux kernel driver is actually any good for anyway. \n\nremove the modules manually\n\n```sh\nsudo modprobe -r msi2500 msi001\n```\n\ncreate a file /etc/modprobe.d/blacklist-msi.conf\n\n```\nblacklist msi001\nblacklist msi2500\n```\n\n### 3.1.2. Soapy SDR\n\ninstall the soapy 'miri' driver:\n\n```sh\nsudo apt install soapysdr-module-mirisdr\n```\n\ntry to find it with SoapySDRUtil\n\n```sh\nSoapySDRUtil --find\n```\n\nresult (for example): \n\n```sh\nFound device 1\n  driver = miri\n  label = Mirics MSi2500 default (e.g. VTX3D card)\n  miri = 0\n```\n\ntry to open with SoapySDRUtil\n\n```sh\n SoapySDRUtil  --probe=\"driver=miri\"\n ```\n or\n ```sh\n SoapySDRUtil  --probe=\"driver=soapyMiri\"\n ```\n\n### 3.1.3. rtl_433\n\n[link](https://github.com/merbanan/rtl_433)\n\ninstall\n```sh\nsudo apt install rtl-433\n```\n\nrun\n```sh\nrtl_433 -d \"\"\n```","tags":["SDR"]},{"title":"PyBind11简明教程","url":"/2024/04/21/PyBind11简明教程/","content":"\npython通过PyBind11调用cpp\n\n## 1.概述\n\n原文链接: [How to Call C++ from Python](https://www.matecdev.com/posts/cpp-call-from-python.html)\n\n翻译整理: [BimAnt](http://www.bimant.com/blog/pybind11-crash-tutorial/)\n\n从 Python 调用 C++ 基本上有两种方法：使用 PyBind11 C++ 库生成 Python 模块，或使用 cytpes Python 包访问已编译的共享库。 使用 PyBind11 我们可以更轻松地共享许多数据类型，而使用 ctypes 是一种低级 C 风格的解决方案。\n\n就我而言，我希望能够利用 C++ 的性能和可移植性，但我不想放弃解释语言的交互性以进行快速探索和调试。\n\n幸运的是，从 Python 调用 C++ 并不像乍看起来那么困难。 这样，我们就可以在开发 C++ 代码的同时掌握 Python 的一些交互性。\n\n就我而言，我想使用 Python 来：\n\n* 将一些问题参数传递给C++\n* 调用 C++ 代码来运行计算密集型例程\n* 检索最终结果以及一些用于调试的中间计算。\n* 以交互方式探索结果，并生成图表和报告。\n\n使用 ctypes 的问题是共享许多数据类型需要大量的低级解决方法。 例如，虽然 ctypes 不支持复数等基本内容，但 PyBind11 使 Numpy 能够与 Eigen 完全互操作，并且需要最少的代码。\n\n不过，我也发现了 PyBind11 的一个小问题。 事实证明，重新编译 C++ 代码并尝试重新加载 PyBind 生成的 Python 模块后，什么也没发生。 重新加载已编译模块的唯一方法是重新启动我的 Python 会话。 无论如何，这不是什么大问题，因为 Python 的启动时间可以忽略不计。 也许，这个步骤可以在 IDE 级别自动化。\n\n因此，现在的问题是如何充分利用 PyBind11。\n\n## 2.与 PyBind11 共享 C++ 类\n\nPyBind11 的官方文档非常好，我能够毫无问题地开始使用它。 然而，我想分享这个库的超级快速入门指南，以及我打算如何使用它。\n\nPybind11 是一个仅包含头文件的库，你可以通过以下方式获取它：\n\n`pip install pybind11`\n\n虽然没有必要将所有 C++ 代码构造为类，但如果你有一个要在 C++ 和 Python 之间共享的类，Pybind11 将使事情变得非常容易。 实际上，我更像是一个struct向量类型的人，我总是想在给定的项目中引入最少数量的类。\n\n然而，在这种情况下，我发现使用外观设计模式（参见 wiki）可以同时带来非常简单的 Python/C++ 互操作性和良好的 API。\n\n所以，我设计了一个简单的类。 它基本上包含：\n\n* 读取问题参数的构造函数。\n* 执行计算的 run() 函数。\n* 一些 Eigen 数组作为公共变量来存储结果。\n\n这是我的最小示例：\n\n```h\n// mylib.h\n#include <Eigen/Dense>\n#include <cmath>\n\nusing Eigen::Matrix, Eigen::Dynamic;\ntypedef Matrix<std::complex<double>, Eigen::Dynamic, Eigen::Dynamic> myMatrix;\n\nclass MyClass {\n\n    int N;\n    double a;\n    double b;\n\npublic:\n\n    Eigen::VectorXd v_data;\n    Eigen::VectorXd v_gamma;\n\n    MyClass(){}\n    MyClass( double a_in, double b_in, int N_in) \n    {\n        N = N_in;\n        a = a_in;\n        b = b_in;\n    }\n\n    void run() \n    { \n        v_data = Eigen::VectorXd::LinSpaced(N, a, b); \n\n        auto gammafunc = [](double it) { return std::tgamma(it); };\n        v_gamma = v_data.unaryExpr(gammafunc);\n    }\n};\n```\n\n为了共享这个类，我们需要添加一些 C++ 代码。 我倾向于在一个单独的文件中执行此操作，其中包含创建 python 包装器所需的所有内容：\n\n```cpp\n// pywrap.cpp\n#include <pybind11/pybind11.h>\n#include <pybind11/eigen.h>\n#include \"mylib.h\"\n\nnamespace py = pybind11;\nconstexpr auto byref = py::return_value_policy::reference_internal;\n\nPYBIND11_MODULE(MyLib, m) {\n    m.doc() = \"optional module docstring\";\n\n    py::class_<MyClass>(m, \"MyClass\")\n    .def(py::init<double, double, int>())  \n    .def(\"run\", &MyClass::run, py::call_guard<py::gil_scoped_release>())\n    .def_readonly(\"v_data\", &MyClass::v_data, byref)\n    .def_readonly(\"v_gamma\", &MyClass::v_gamma, byref)\n    ;\n}\n```\n\n有几点需要强调：\n\n* 类构造函数签名由 .def(py::init<int, double, double>())  指定\n* 对于 run() 函数，我们要求释放 GIL（全局解释器锁），这将阻止我们的函数使用多个线程。\n* 最后，可以使用以下 CMakeLists.txt 文件进行编译：\n\n```CMakeLists\ncmake_minimum_required(VERSION 3.10)\n\nproject(MyLib)\nset(CMAKE_CXX_STANDARD 20)\nset(PYBIND11_PYTHON_VERSION 3.6)\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -fPIC\")\n\nfind_package(pybind11 REQUIRED)\nfind_package(Eigen3 REQUIRED)\n\npybind11_add_module(${PROJECT_NAME} pywrap.cpp)\n\ntarget_compile_definitions(${PROJECT_NAME} PRIVATE VERSION_INFO=${EXAMPLE_VERSION_INFO})\ntarget_include_directories(${PROJECT_NAME} PRIVATE ${PYBIND11_INCLUDE_DIRS})\ntarget_link_libraries(${PROJECT_NAME} PRIVATE Eigen3::Eigen)\n```\n现在已准备好了。 如果你使用 VS Code，配置 CMake 扩展后，只需按 F7 即可编译 C++ 库。\n\n## 3.从 Python 调用 C++ 库\n\n这个过程非常简单，并且应该开箱即用。 然而，有一些步骤可以优化交互式工作流程，这些步骤稍微棘手，但也值得实施。\n\n例如，如果正在执行 Python 环境并且编译的库进入构建目录，可以执行以下操作：\n\nimport sys\nsys.path.append(\"build/\")\nfrom MyLib import MyClass\n\nimport matplotlib.pyplot as plt\n\nSimulation = MyClass(-4,4,1000)\nSimulation.run()\n\nplt.plot(Simulation.v_data, Simulation.v_gamma, \\\n\"--\", linewidth = 3, color=(1,0,0,0.6),label=\"Function Value\")\nplt.ylim(-10,10)\nplt.xlabel(\"x\")\nplt.ylabel(\"($f(x) = \\gamma(x)$)\")\nplt.title(\"(Gamma Function: $\\gamma(z) = \\int_0^\\infty x^{z-1} e^{-x} dx$)\",fontsize = 18);\nplt.show()\n\n结果如下：\n\n![Gamma](image-137.png)\n\n请注意，特征向量会自动转换为 Python 数组。\n\n修改 myLib.hpp 后，只需在 pywrap.cpp 中为我们要公开的每个新函数或变量添加一行代码。\n\n不幸的是，这不会导致完全交互式的工作流程。 当你在更改后重新编译 C++ 代码时，Python 端不会发生任何事情。 即使尝试使用 importtools 重新加载 Python 模块：\n\n```sh\nimport importlib\nimportlib.reload(MyLib)\n```\n\n什么都没发生。 原因是编译后的代码无法在Python中重新加载。\n\n因此，使用 PyBind11 时，每次重新编译 C++ 代码时都需要重新启动 Python 会话，这对于开发目的来说有点烦人。 然而，这是一个很小的代价，因为 Python 的启动时间可以忽略不计，并且可能有一种方法可以使用一些 IDE 热键或其他工具来自动化该过程。\n\n## 4.结束语\n\n好了，这就是可以轻松地从 Python 调用 C++ 库的方法。教程的示例代码可以从github获取。\n\n特别是，这个两步过程可以产生非常交互式的开发工作流程。 尽管我们有一个编辑-编译-运行工作流程，但我们在最后添加了一个解释器，所以现在我们的工作流程看起来像编辑-编译-运行-探索。\n\n将来，我计划将两个功能合并到此工作流程中：\n\n* 第一个是 C++20 模块，它应该可以加快大型 C++ 项目的编译时间。 不幸的是，CMake 仍然与模块不兼容（请参阅此问题以获取更新），并且显然必须依赖像 Ninja-Build 这样的构建系统才能立即使用此功能。\n* 另一件事是修复重新编译 C++ 代码后（手动）重新启动 Python 会话的需要。 为此，我希望也许可以在 VSCode 级别对此采取一些措施。 到目前为止，VS Code 中的最佳选项似乎是终止 Python 会话，然后使用 Shift+Enter 执行 Python 代码，如果尚未打开会话，则会创建一个新会话。","tags":["Python"]},{"title":"Windows系统中使用CMake配置OpenCV的CPP环境","url":"/2024/04/18/Windows系统中使用Cmake配置OpenCV的CPP环境/","content":"\nWindows CMake OpenCV C++\n\n## 1.概述\n\nWindows系统中使用Cmake配置OpenCV的C++环境\n\n参考[Link](https://www.youtube.com/watch?v=CnXUTG9XYGI)\n\n## 2.下载并解压 [opencv](https://opencv.org/releases/)\n\n选择Windows，不要选择Sources\n\n## 3.下载并安装cmake\n\n省略...\n\n## 4.编辑系统环境变量\n\n在Path 增加以下三项(根据安装位置修改路径)\n\n```\nC:\\Program Files\\CMake\\bin\nD:\\opencv\\build\\x64\\vc15\\bin\nD:\\opencv\\build\\x64\\vc15\\lib\n```\n\n## 5.新建文件夹及内部的文件\n```\nHelloOpenCV\n└─src\n    └─main.cpp\nCMakeLists.txt\n1.jpg\n```\n\n```cpp\n//main.cpp\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nint main()\n{\n    std::string imagePath = \"1.jpg\";\n    cv::Mat image = cv::imread(imagePath, cv::IMREAD_COLOR);\n    cv::imshow(\"Display window\", image);\n    cv::waitKey(0);\n    return 0;\n}\n```\n\n根据安装位置修改 `OpenCV_DIR` 的值\n```CMake\n# CMakeLists.txt\ncmake_minimum_required(VERSION 3.0)\nproject(HelloOpenCV)\n\nset(OpenCV_DIR \"D:/opencv/build/x64/vc15/lib\")\n\nfind_package(OpenCV REQUIRED)\n\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n\nadd_executable(HelloOpenCV src/main.cpp)\n\ntarget_link_libraries(HelloOpenCV ${OpenCV_LIBS})\n```\n\n## 6.Terminal 中编译\n\n```PowerShell\nmkdir build\ncmake -B .\\build\\\n```\n\nDebug\n```PowerShell\ncmake --build .\\build\\\n.\\build\\Debug\\HelloOpenCV.exe\n```\n\nRelease\n```PowerShell\ncmake --build .\\build\\ --config Release\n.\\build\\Release\\HelloOpenCV.exe\n```","tags":["OpenCV"]},{"title":"Ubuntu-OpenCV-CPP-Without-IDE","url":"/2024/04/13/Ubuntu-OpenCV-CPP-Without-IDE/","content":"\nUbuntu OpenCV CMake\n\n## 1.Building packages\n\n1. update packages list\n\n```sh\nsudo apt update\n```\n\n2. Install building packages\n\n```sh\nsudo apt -y install build-essential\n```\n\n## 2.Install OpenCV from Ubuntu Repositories\n\n[link](https://phoenixnap.com/kb/installing-opencv-on-ubuntu)\n\n1. Install OpenCV\n\n```sh\nsudo apt -y install libopencv-dev\n```\n\n2. Check the OpenCV version\n\n```sh\ndpkg -l libopencv-dev\n```\n\n## 3.Install CMake\n\n```sh\nsudo apt -y install cmake\ncmake --version\n```\n\n## 4.Create CPP Projetct\n\n[link](https://docs.opencv.org/4.x/db/df5/tutorial_linux_gcc_cmake.html)\n\n```sh\nDisplayImage\n├── build\n│   └── \n├── CMakeLists.txt\n├── cmake-modules\n│   └── OpenCVConfig.cmake\n├── img\n│   └── lenna.jpeg\n└── src\n    └── DisplayImage.cpp\n```\n\n```cpp\n// DisplayImage.cpp\n\n#include <stdio.h>\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\nint main(int argc, char **argv)\n{\n    if (argc != 2)\n    {\n        printf(\"usage: DisplayImage.out <Image_Path>\\n\");\n        return -1;\n    }\n\n    Mat image;\n    image = imread(argv[1], IMREAD_COLOR);\n\n    if (!image.data)\n    {\n        printf(\"No image data \\n\");\n        return -1;\n    }\n    namedWindow(\"Display Image\", WINDOW_AUTOSIZE);\n    imshow(\"Display Image\", image);\n\n    waitKey(0);\n\n    return 0;\n}\n```\n\n\n```\n# CMakeLists.txt\n\n# CMake 最低版本号要求\ncmake_minimum_required(VERSION 3.6)\n\n# 项目信息\nproject(DisplayImage)\n\n# 将cmake-modules文件夹中的文件加入 CMAKE_MODULE_PATH\nlist(APPEND CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/cmake-modules\")\n\n# 查找并从外部项目加载设置\n# REQUIRED如果找不到软件包，该选项将停止处理并显示一条错误消息\nfind_package(OpenCV REQUIRED)\n\n# 将给定目录添加到编译器用来搜索包含文件的目录中。相对路径被解释为相对于当前源目录\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n\n# 利用源码文件生成目标可执行程序\nadd_executable(DisplayImage src/DisplayImage.cpp)\n\n# 添加链接库\ntarget_link_libraries(DisplayImage ${OpenCV_LIBS})\n```\n\n## 5.Find OpenCV Config\n\n[link](https://wiki.hanzheteng.com/development/cmake/cmake-find_package)\n\n```sh\nsudo find / -name \"OpenCVConfig.cmake\"\n```\n\ncopy to cmake-modules folder\n\n## 6.Build and Test\n\n```sh\ncd build\ncmake ..\nmake\n./DisplayImage ../img/lenna.jpeg\n```\n\nmaybe need `chmod +x DisplayImage`\n\n![test](Screenshot_test.png)\n\n\n## 7.VSCode Debug\n\n* Install Extensions\n\n![install_Extensions](Screenshot_VSCode_Extensions.png)\n\n* restart and set cmake\n\n![set_cmake](Screenshot_set_cmake.png)\n\n* add breakpoint and click Debug button\n\n![breakpoint](Screenshot_set_breakpoint.png)\n\n* Debugging\n\n![run_debug](Screenshot_Debug.png)\n\n* set pic path for main args\n\nplease tell me...\n\n\n","tags":["OpenCV"]},{"title":"opencv交叉编译","url":"/2024/02/25/opencv交叉编译/","content":"\n## 1.概述\n\nUbuntu x86 交叉编译 aarm64 OpenCV 3.4.5\n\n[参考](https://www.codenong.com/cs105274123/)\n\n## 2.环境\n\nUbuntu 18.04 aarm64    OpenCV3.4.5  目标arm64\n\n源码\n\n OpenCV源码下载地址: https://opencv.org/releases/ \n\n安装交叉编译器\n\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n安装cmake\n\n```bash\nsudo apt install cmake cmake-gui\n```\n\n解压OpenCV\n\n## 3.使用cmake-gui生成Makefile\n\n![img](20200402174348844.png) \n\n![img](20200402174507776.png) \n\n![img](20200402174708819.png) \n\n![img](20200402174747432.png) \n\n![img](20200402175311654.png) \n\n查看是否生成Makefile文件\n\n## 4.编译\n\n```bash\nmake && make install\n```\n\n用file指令查看编译出的可执行文件\n\n```bash\nfile bin/opencv_version\n```\n\n将文件加install中生成的文件移动到aarm64文件夹，方面查找和使用。\n\n## 5.编译例程\n\n 在这个opencv-3.4.5/samples/cpp/example_cmake目录里官方已经给出了一个example可以拿来测试下，使用编译器编译，编译时加上OpenCV相关的库和头文件。 \n\n```bash\ng++ example.cpp -o aarm64 -I /home/yi/opencv/aarm64/include/ -L /home/yi/opencv/aarm64/lib/ -lopencv_calib3d -lopencv_objdetect -lopencv_core -lopencv_photo -lopencv_dnn -lopencv_shape -lopencv_features2d  -lopencv_stitching -lopencv_flann -lopencv_superres -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs  -lopencv_video -lopencv_imgproc -lopencv_videostab -lopencv_ml\n```\n\n库、头文件和可执行文件移动到目标板（若cmake-gui选择编译平台为gnu，即可在本地测试无需拷贝文件）\n\n## 6.设置动态库路径\n\n```bash\nexport LD_LIBRARY_PATH=/home/yi/opencv/aarm64/lib/:$LD_LIBRARY_PATH\n```\n\n## 7.运行\n\n\n```bash\n./aarm64\n```\n\n软件运行界面\n\n![1668051815828](1668051815828.png)","tags":["OpenCV"]},{"title":"Ubuntu安装QT交叉编译环境","url":"/2024/02/25/Ubuntu安装QT交叉编译环境/","content":"\n## 1.Ubuntu 安装QT交叉编译环境\n\n[参考](https://blog.csdn.net/guohuaqu/article/details/109519744)\n\n需求实现再x86机器下完成对ARM64平台的程序开发\n\n## 2.安装ARM64编译器\n\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n查看\n\n![shell aarch64-linux-gnu-](1667790599228.png)\n\n## 3.安装qt开发环境\n\nqt安装包：qt-opensource-linux-x64-5.12.12.run\n\nsudo chmod +x，然后运行，就会出现图形界面，按步骤一步步安装即可。\n\n## 4.安装qt工具\n\nARM64交叉编译器，例如qmake、库等\n\n下载qt源码包：[qt-everywhere-src-5.12.12.tar.xz](http://download.qt.io/archive/qt/5.14/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz) \n\n解压 xz -d qt-everywhere-src-5.12.12.tar.xz\n\n修改编译配置文件\n\n```bash\nyi@linux:~/Downloads/qt-everywhere-src-5.12.12/qtbase/mkspecs$ ls\naix-g++                macx-xcode\naix-g++-64             modules\nandroid-clang          modules-inst\nandroid-g++            netbsd-g++\ncommon                 openbsd-g++\ncygwin-g++             qconfig.pri\ndarwin-g++             qdevice.pri\ndevices                qmodule.pri\ndummy                  qnx-aarch64le-qcc\nfeatures               qnx-armle-v7-qcc\nfreebsd-clang          qnx-x86-64-qcc\nfreebsd-g++            qnx-x86-qcc\nhaiku-g++              solaris-cc\nhpuxi-g++-64           solaris-cc-64\nhurd-g++               solaris-cc-64-stlport\nintegrity-armv7        solaris-cc-stlport\nintegrity-armv7-imx6   solaris-g++\nintegrity-armv8-rcar   solaris-g++-64\nintegrity-x86          unsupported\nlinux-aarch64-gnu-g++  wasm-emscripten\nlinux-arm-gnueabi-g++  win32-arm64-msvc2017\nlinux-clang            win32-clang-g++\nlinux-clang-libc++     win32-clang-msvc\nlinux-g++              win32-g++\nlinux-g++-32           win32-icc\nlinux-g++-64           win32-icc-k1om\nlinux-icc              win32-msvc\nlinux-icc-32           winrt-arm64-msvc2017\nlinux-icc-64           winrt-arm64-msvc2019\nlinux-icc-k1om         winrt-arm-msvc2015\nlinux-llvm             winrt-arm-msvc2017\nlinux-lsb-g++          winrt-arm-msvc2019\nlynxos-g++             winrt-x64-msvc2015\nmacx-clang             winrt-x64-msvc2017\nmacx-g++               winrt-x64-msvc2019\nmacx-icc               winrt-x86-msvc2015\nmacx-ios-clang         winrt-x86-msvc2017\nmacx-tvos-clang        winrt-x86-msvc2019\n```\n\n查看修改配置文件 vim linux-aarch64-gnu-g++/qmake.conf\n\n```bash\n#\n# qmake configuration for building with aarch64-linux-gnu-g++\n#\n\nMAKEFILE_GENERATOR      = UNIX\nCONFIG                 += incremental\nQMAKE_INCREMENTAL_STYLE = sublib\n\ninclude(../common/linux.conf)\ninclude(../common/gcc-base-unix.conf)\ninclude(../common/g++-unix.conf)\n\n# modifications to g++.conf\nQMAKE_CC                = aarch64-linux-gnu-gcc\nQMAKE_CXX               = aarch64-linux-gnu-g++\nQMAKE_LINK              = aarch64-linux-gnu-g++\nQMAKE_LINK_SHLIB        = aarch64-linux-gnu-g++\n\n# modifications to linux.conf\nQMAKE_AR                = aarch64-linux-gnu-ar cqs\nQMAKE_OBJCOPY           = aarch64-linux-gnu-objcopy\nQMAKE_NM                = aarch64-linux-gnu-nm -P\nQMAKE_STRIP             = aarch64-linux-gnu-strip\nload(qt_config)\n```\n\n开始编译：\n\n 进入根目录cd qt-everywhere-src-5.12.12 \n\n```bash\n./configure -prefix /home/yi/Qt5.12.12/5.12.12/aarch64 -make libs -xplatform linux-aarch64-gnu-g++ -no-opengl -skip qtdeclarative\n```\n\n-prefix 代表你的安装文件夹\n\n-xplatform 代表你所制定的编译器\n\nno-opengl 跳过编译openGL(因为我已经安装了Qt，所以不需要界面)\n\n-skip qtdeclarative 跳过 qtdeclarative（不跳过，编译出错，出错的原因不清楚）\n\n线程开到了最大，并把log存在了本地。编译具体时间比较依赖自己PC的配置。\n\n```bash\nmake -j16 2>&1 | tee build.log\n```\n创建安装文件夹\n\n```bash\nMkdir -p Qt5.12.12/5.12.12/aarch64\n```\n安装\n\n```bash\nmake install\n```\n查看结果\n\n```bash\nyi@linux:~/Qt5.12.12/5.12.12/aarch64$ ls\nbin  doc  include  lib  mkspecs  plugins  translations\n```\n## 5.配置Qt，添加交叉编译环境\n\n4.配置Qt，添加交叉编译环境\n\na.打开Qt\n\nb.tools → options,打开面板\n\nc.设置compilers,手动添加ARM64交叉编译器\n\nadd c\n\n![commpilers](commpilers.png)\n\n\nd.手动add qt version\n\n![qt kits-Versions](1667797779321.png)\n\ne.手动add Kits\n\n![qt kits-Manual](1667797929755.png)\n\n![qt Debugger](1667797958269.png)\n\n## 6.新建工程&编译\n\n选择刚刚手动添加的kits\n\n","tags":["Qt"]},{"title":"Pycharm+Anaconda+QtDesigner开发完整配置攻略","url":"/2024/02/12/Pycharm-Anaconda-QtDesigner开发完整配置攻略/","content":"\n搭建QyQt开发环境\n\nPyCharm + Anaconda(或miniconda) + Qt Designer\n\n## 1.PyCharm下载安装\npycharm 社区版\n\n## 2.Anaconda下载安装\n\n[anaconda](https://repo.anaconda.com/archive/Anaconda3-2021.05-Windows-x86_64.exe)\n\nanaconda mirror\n\n## 3.设置pypi源\n\npycharm project\n\n```\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n## 4.安装软件包\n\n```\npip install -r requirements.txt\n```\n\n## 5.查看python版本\n\n```\nC:\\Users\\替换为用户名>pip -V\npip 21.0.1 from E:\\ProgramData\\Anaconda3\\lib\\site-packages\\pip (python 3.8)\n```\n\n## 6.conda 添加中科大源\n[https://blog.csdn.net/R18830287035/article/details/90633942](https://blog.csdn.net/R18830287035/article/details/90633942)\n\n```\nC:\\Users\\替换为用户名>\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/\nconda config --set show_channel_urls yes\n```\n\n```\nC:\\Users\\替换为用户名>\nconda config --show channels\nchannels:\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n  - defaults\n```\n\n## 7.PyCharm+Qt Designer+PyUIC安装配置教程\n\n[https://www.cnblogs.com/lsdb/p/9121903.html](https://www.cnblogs.com/lsdb/p/9121903.html)\n\n\n## 8.PyCharm Setting\n\n```\nTools - External Tools\n  Qt-QtDesigner \n    Name: QtDesigner\n    Group: Qt\n    Program: E:\\ProgramData\\Anaconda3\\envs\\py37ccd\\Lib\\site-packages\\PySide2\\designer.exe\n    Working dir: $FileDir$\n  Qt-PyUIC\n    Name: PyUIC\n    Group: Qt\n    Program: E:\\ProgramData\\Anaconda3\\envs\\py37ccd\\python.exe\n    Arguments: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py\n    Working dir: $FileDir$\n```\n\n## 9.PyCharm+QTDesigner+PyUIC使用教程\nhttps://www.cnblogs.com/lsdb/p/9122425.html\n","tags":["PyQt"]},{"title":"esp32通过lvgl库驱动触摸屏","url":"/2023/08/06/esp32通过lvgl库驱动触摸屏/","content":"\n在ESP32开发板上使用LVGL框架开发LCD显示屏界面\n\n显示框架：LVGL\n\nTFT芯片：ST7789\n\n电容触摸芯片：CST816S\n\n![run_demo](run_demo.png)\n\n## 1.TFT_eSPI drive LCD\n\nhttps://github.com/Bodmer/TFT_eSPI/discussions/2555\n\nThis wiki page was useful: [Github](https://github.com/Bodmer/TFT_eSPI/wiki/Installing-on-PlatformIO)\n\nThat said, there are some missing parts that due to the state of the library will show up as a non-functioning screen. For my use case (an ILI9488 device), I needed to provide additional values. I believe some of these are necessary for all projects.\n\nHere is the bare minimum project using Visual Studio Code with PlatformIo and using the technique of platformio.ini file modification. No library file modification needed!\n\nplatformio.ini:\n\n```\n[env:nodemcu-32s]\nplatform = espressif32\nboard = nodemcu-32s\nframework = arduino\nmonitor_speed = 115200\nlib_deps = bodmer/TFT_eSPI@^2.5.23\nbuild_flags =\n-D USER_SETUP_LOADED\n-D ILI9488_DRIVER\n-D TFT_MISO=19\n-D TFT_MOSI=23\n-D TFT_SCLK=18\n-D TFT_CS=15\n-D TFT_DC=2\n-D TFT_RST=4\n-D LOAD_GLCD=1\n-D SMOOTH_FONT\n-D SPI_FREQUENCY=27000000\n```\n\nmain.cpp:\n\n```c++\n#include <Arduino.h>\n#include <TFT_eSPI.h> // Hardware-specific library\nTFT_eSPI tft = TFT_eSPI(); // Invoke custom library\n\nvoid setup()\n{\nSerial.begin(115200); // For debug\ntft.init();\n\ntft.setRotation(1);\ntft.fillScreen(TFT_GREEN);\n}\n\nvoid loop()\n{\n// put your main code here, to run repeatedly:\n}\n```\n\nNote that I had to include USER_SETUP_LOADED as well as SMOOTH_FONT.\n\nThere are some minor errors in the wiki article. It projects like we need to have an =1 but I found it works just like the include system and is not necessary.\n\n\n## 2.My project, need offset.\n\nplatformio.ini:\n\n```c++\n[env:wesp32]\nplatform = espressif32\nboard = wesp32\nframework = arduino\nmonitor_speed = 115200\nupload_speed = 230400\nboard_build.partitions = default_16MB.csv\nboard_upload.flash_size = 16MB\nlib_deps = \n\tbodmer/TFT_eSPI@^2.5.30\n    lvgl/lvgl@^8.3.7\nbuild_flags = \n\t-D USER_SETUP_LOADED\n\t-D ST7789_DRIVER\n\t-D CGRAM_OFFSET\n\t-D TFT_MOSI=23\n\t-D TFT_SCLK=18\n\t-D TFT_DC=2\n\t-D TFT_RST=4\n\t-D LOAD_GLCD=1\n\t-D SMOOTH_FONT\n\t-D SPI_FREQUENCY=55000000\n```\n\n## 3.lvgl\n\nmain.cpp\n```c++\n/*Using LVGL with Arduino requires some extra steps:\n *Be sure to read the docs here: https://docs.lvgl.io/master/get-started/platforms/arduino.html  */\n\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n\n/*To use the built-in examples and demos of LVGL uncomment the includes below respectively.\n *You also need to copy `lvgl/examples` to `lvgl/src/examples`. Similarly for the demos `lvgl/demos` to `lvgl/src/demos`.\n Note that the `lv_examples` library is for LVGL v7 and you shouldn't install it for this version (since LVGL v8)\n as the examples and demos are now part of the main LVGL library. */\n\n/*Change to your screen resolution*/\nstatic const uint16_t screenWidth  = 240;\nstatic const uint16_t screenHeight = 280;\n\nstatic lv_disp_draw_buf_t draw_buf;\nstatic lv_color_t buf[ screenWidth * 10 ];\n\nTFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */\n\n#if LV_USE_LOG != 0\n/* Serial debugging */\nvoid my_print(const char * buf)\n{\n    Serial.printf(buf);\n    Serial.flush();\n}\n#endif\n\n/* Display flushing */\nvoid my_disp_flush( lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p )\n{\n    uint32_t w = ( area->x2 - area->x1 + 1 );\n    uint32_t h = ( area->y2 - area->y1 + 1 );\n\n    tft.startWrite();\n    tft.setAddrWindow( area->x1, area->y1, w, h );\n    tft.pushColors( ( uint16_t * )&color_p->full, w * h, true );\n    tft.endWrite();\n\n    lv_disp_flush_ready( disp );\n}\n\nvoid setup()\n{\n    Serial.begin( 115200 ); /* prepare for possible serial debug */\n\n    String LVGL_Arduino = \"Hello Arduino! \";\n    LVGL_Arduino += String('V') + lv_version_major() + \".\" + lv_version_minor() + \".\" + lv_version_patch();\n\n    Serial.println( LVGL_Arduino );\n    Serial.println( \"I am LVGL_Arduino\" );\n\n    lv_init();\n\n#if LV_USE_LOG != 0\n    lv_log_register_print_cb( my_print ); /* register print function for debugging */\n#endif\n\n    tft.begin();          /* TFT init */\n    tft.setRotation( 4 ); /* 2:top fpc 4:bottom fpc */\n\n    lv_disp_draw_buf_init( &draw_buf, buf, NULL, screenWidth * 10 );\n\n    /*Initialize the display*/\n    static lv_disp_drv_t disp_drv;\n    lv_disp_drv_init( &disp_drv );\n    /*Change the following line to your display resolution*/\n    disp_drv.hor_res = screenWidth;\n    disp_drv.ver_res = screenHeight;\n    disp_drv.flush_cb = my_disp_flush;\n    disp_drv.draw_buf = &draw_buf;\n    lv_disp_drv_register( &disp_drv );\n\n    /* Create simple label */\n    lv_obj_t *label_top = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_top, LVGL_Arduino.c_str() );\n    lv_obj_align( label_top, LV_ALIGN_TOP_LEFT, 0, 0 );\n\n    lv_obj_t *label = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label, LVGL_Arduino.c_str() );\n    lv_obj_align( label, LV_ALIGN_CENTER, 0, 0 );\n\n    lv_obj_t *label_bottom = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_bottom, LVGL_Arduino.c_str() );\n    lv_obj_align( label_bottom, LV_ALIGN_BOTTOM_RIGHT, 0, 0 );\n\n    Serial.println( \"Setup done\" );\n}\n\nvoid loop()\n{\n    lv_timer_handler(); /* let the GUI do its work */\n    delay( 5 );\n}\n```\n\n## 4.lvgl+touch\nplatformio.ini:\n```c++\n[env:wesp32]\nplatform = espressif32\nboard = wesp32\nframework = arduino\nmonitor_speed = 115200\nupload_speed = 230400\nboard_build.partitions = default_16MB.csv\nboard_upload.flash_size = 16MB\nlib_deps = \n\tbodmer/TFT_eSPI@^2.5.30\n    fbiego/CST816S@^1.1.0\n    lvgl/lvgl@^8.3.7\nbuild_flags = \n\t-D USER_SETUP_LOADED\n\t-D ST7789_DRIVER\n\t-D CGRAM_OFFSET\n\t-D TFT_MOSI=23\n\t-D TFT_SCLK=18\n\t-D TFT_DC=2\n\t-D TFT_RST=4\n\t-D LOAD_GLCD=1\n\t-D SMOOTH_FONT\n\t-D SPI_FREQUENCY=55000000\n```\n\nmain.cpp\n```c++\n/*Using LVGL with Arduino requires some extra steps:\n *Be sure to read the docs here: https://docs.lvgl.io/master/get-started/platforms/arduino.html  */\n\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n#include <CST816S.h>\n\n\n/*To use the built-in examples and demos of LVGL uncomment the includes below respectively.\n *You also need to copy `lvgl/examples` to `lvgl/src/examples`. Similarly for the demos `lvgl/demos` to `lvgl/src/demos`.\n Note that the `lv_examples` library is for LVGL v7 and you shouldn't install it for this version (since LVGL v8)\n as the examples and demos are now part of the main LVGL library. */\n\n/*Change to your screen resolution*/\nstatic const uint16_t screenWidth  = 240;\nstatic const uint16_t screenHeight = 280;\n\nstatic lv_disp_draw_buf_t draw_buf;\nstatic lv_color_t buf[ screenWidth * 10 ];\n\nTFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */\n\nCST816S touch(15, 4, 5, 34);\t// sda, scl, rst, irq\n\n#if LV_USE_LOG != 0\n/* Serial debugging */\nvoid my_print(const char * buf)\n{\n    Serial.printf(buf);\n    Serial.flush();\n}\n#endif\n\n/* Display flushing */\nvoid my_disp_flush( lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p )\n{\n    uint32_t w = ( area->x2 - area->x1 + 1 );\n    uint32_t h = ( area->y2 - area->y1 + 1 );\n\n    tft.startWrite();\n    tft.setAddrWindow( area->x1, area->y1, w, h );\n    tft.pushColors( ( uint16_t * )&color_p->full, w * h, true );\n    tft.endWrite();\n\n    lv_disp_flush_ready( disp );\n}\n\n/*Read the touchpad*/\nvoid my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data )\n{\n    bool touched = touch.available();\n\n    if( !touched )\n    {\n        data->state = LV_INDEV_STATE_REL;\n    }\n    else\n    {\n        data->state = LV_INDEV_STATE_PR;\n\n        /*Set the coordinates*/\n        data->point.x = touch.data.x;\n        data->point.y = touch.data.y;\n\n        Serial.print( \"Data x \" );\n        Serial.println( touch.data.x );\n\n        Serial.print( \"Data y \" );\n        Serial.println( touch.data.y );\n    }\n}\n\nvoid setup()\n{\n    Serial.begin( 115200 ); /* prepare for possible serial debug */\n\n    String LVGL_Arduino = \"Hello Arduino! \";\n    LVGL_Arduino += String('V') + lv_version_major() + \".\" + lv_version_minor() + \".\" + lv_version_patch();\n\n    Serial.println( LVGL_Arduino );\n    Serial.println( \"I am LVGL_Arduino\" );\n\n    lv_init();\n\n#if LV_USE_LOG != 0\n    lv_log_register_print_cb( my_print ); /* register print function for debugging */\n#endif\n\n    tft.begin();          /* TFT init */\n    tft.setRotation( 2 ); /* 2:top fpc 4:bottom fpc */\n\n    touch.begin();\n    Serial.print(touch.data.version);\n    Serial.print(\"\\t\");\n    Serial.print(touch.data.versionInfo[0]);\n    Serial.print(\"-\");\n    Serial.print(touch.data.versionInfo[1]);\n    Serial.print(\"-\");\n    Serial.println(touch.data.versionInfo[2]);\n\n    lv_disp_draw_buf_init( &draw_buf, buf, NULL, screenWidth * 10 );\n\n    /*Initialize the display*/\n    static lv_disp_drv_t disp_drv;\n    lv_disp_drv_init( &disp_drv );\n    /*Change the following line to your display resolution*/\n    disp_drv.hor_res = screenWidth;\n    disp_drv.ver_res = screenHeight;\n    disp_drv.flush_cb = my_disp_flush;\n    disp_drv.draw_buf = &draw_buf;\n    lv_disp_drv_register( &disp_drv );\n\n    /*Initialize the (dummy) input device driver*/\n    static lv_indev_drv_t indev_drv;\n    lv_indev_drv_init( &indev_drv );\n    indev_drv.type = LV_INDEV_TYPE_POINTER;\n    indev_drv.read_cb = my_touchpad_read;\n    lv_indev_drv_register( &indev_drv );\n\n    /* Create simple label */\n    lv_obj_t *label_top = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_top, LVGL_Arduino.c_str() );\n    lv_obj_align( label_top, LV_ALIGN_TOP_LEFT, 0, 0 );\n\n    lv_obj_t *label = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label, LVGL_Arduino.c_str() );\n    lv_obj_align( label, LV_ALIGN_CENTER, 0, 0 );\n\n    lv_obj_t *label_bottom = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_bottom, LVGL_Arduino.c_str() );\n    lv_obj_align( label_bottom, LV_ALIGN_BOTTOM_RIGHT, 0, 0 );\n\n    Serial.println( \"Setup done\" );\n}\n\nvoid loop()\n{\n    lv_timer_handler(); /* let the GUI do its work */\n    delay( 5 );\n}\n\n```\n\n## 5.lvgl demo\n\n使用官方demos流程：\n\n* lv_conf.h 中 `#define LV_USE_DEMO_WIDGETS 1`\n* 将lvgl库中的demos移动到src文件夹。不然会出现`undefined reference to 'lv_demo_benchmark' `（例如lv_demo_benchmark） 这是由于lv_demo_benchmark.c未被编译导致的 把demos文件夹移动到lvgl的src目录下就行了，这样就会参与到编译中了\n* 包含头文件，例如在main.c文件中 `#include \"demos/lv_demos.h\"`\n* 初始化等参考官方例程，setup中调用demo中的函数即可。 `lv_demo_widgets();`\n\n\n## 面包板测试\n\n注意核对FPC座的线序(1脚的位置)\n\n| ESP32 | FPC | Function | Other             |\n| ----- | --- | -------- | ----------------- |\n| GND   | 1   | GND      |                   |\n| GND   | 2   | LED_K    | 可通过PWM调整亮度 |\n| 3V3   | 3   | VDD      | 供电              |\n| 3V3   | 4   | VDD      |                   |\n| GND   | 5   | GND      |                   |\n| GND   | 6   | GND      |                   |\n| 2     | 7   | D/C      |                   |\n| GND   | 8   | CS       | 默认拉低一直有效  |\n| 18    | 9   | SCL      | SPI_SCL           |\n| 23    | 10  | SDA      | SPI_MOSI          |\n| 32    | 11  | REST     | LCD_RST           |\n| GND   | 12  | GND      |                   |\n| 4     | 13  | TP_SCL   | I2C0_SCL          |\n| 15    | 14  | TP_SDA   | I2C0_SDA          |\n| 5     | 15  | TP_RST   | Touch_RST         |\n| 34    | 16  | TP_INT   | Touch_INT         |\n| 3V3   | 17  | VDD      |                   |\n| GND   | 18  | GND      |                   |\n\n## 6.使用自己设计的PCB板\n\nControler_ESP32_V0.1（PFC座方向反了）\n\n| ESP32        | FPC | Function | Other               |\n| ------------ | --- | -------- | ------------------- |\n| GND          | 1   | GND      |                     |\n| GND          | 2   | LED_K    | 可通过PWM调整亮度   |\n| 3V3          | 3   | VDD      | 供电                |\n| 3V3          | 4   | VDD      |                     |\n| GND          | 5   | GND      |                     |\n| GND          | 6   | GND      |                     |\n| 2            | 7   | D/C      |                     |\n| 32           | 8   | CS       |                     |\n| 18           | 9   | SCL      | SPI_SCL             |\n| 23           | 10  | SDA      | SPI_MOSI            |\n| PCA9535 IO10 | 11  | REST     | IO扩展芯片 I2C0控制 |\n| GND          | 12  | GND      |                     |\n| 4            | 13  | TP_SCL   | I2C0_SCL            |\n| 15           | 14  | TP_SDA   | I2C0_SDA            |\n| PCA9535 IO11 | 15  | TP_RST   | IO扩展芯片 I2C0控制 |\n| 34           | 16  | TP_INT   | Touch_INT           |\n| 3V3          | 17  | VDD      |                     |\n| GND          | 18  | GND      |                     |\n\n\n\n","tags":["ESP32"]},{"title":"局域网内Raspberry上报IP地址脚本编写及部署","url":"/2023/08/06/局域网内Raspberry上报IP地址脚本编写及部署/","content":"\nIP UDP Python Shell\n\n## 1.安装python包\n\n```bash\nsudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple netifaces\n```\n\n## 2.将脚本复制到指定的目录\n\n/usr/local/bin/send_ipaddr_broadcast.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport socket\nimport netifaces\nimport signal\nimport sys\nimport time\n\ndef send_broadcast_message(sock):\n    # 获取树莓派的IP地址\n    interfaces = netifaces.interfaces()\n    for iface in interfaces:\n        addrs = netifaces.ifaddresses(iface)\n        if netifaces.AF_INET in addrs:\n            ip = addrs[netifaces.AF_INET][0]['addr']\n            if ip.find('127.0.0.1') >= 0:\n                continue\n\n            # 发送UDP广播消息\n            broadcast_ip = '255.255.255.255'  # 广播地址\n            port = 7893  # 自定义端口号\n\n            message = \"Raspberry IP address is {}\".format(ip)\n\n            try:\n                sock.sendto(message.encode(), (broadcast_ip, port))\n            except socket.error as e:\n                print(\"Failed to send broadcast message:\", str(e))\n\ndef sigterm_handler(signal, frame):\n    # 执行清理操作，例如关闭套接字等\n    if sock:\n        sock.close()\n    sys.exit(0)\n\n# 创建非阻塞式套接字\nsock = None\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    sock.setblocking(0)  # 设置为非阻塞式套接字\nexcept socket.error as e:\n    print(\"Failed to create socket:\", str(e))\n    sys.exit(1)\n\n# 注册SIGTERM信号处理函数\nsignal.signal(signal.SIGTERM, sigterm_handler)\n\n# 设置等待时间间隔\nwait_interval = 5  # 5秒\n\n# 循环发送UDP广播消息\nstart_time = time.time()\nwhile True:\n    try:\n        current_time = time.time()\n        if current_time - start_time >= wait_interval:\n            send_broadcast_message(sock)\n            start_time = current_time\n        time.sleep(1)  # 休眠1秒，降低CPU使用率\n    except KeyboardInterrupt:\n        # 如果收到键盘中断信号，退出循环\n        break\n\n# 关闭套接字\nif sock:\n    sock.close()\n```\n\n\n## 3.新建系统服务\n\n* 将send_ipaddr_broadcast.py复制到/etc/systemd/system/\n\n```shell\n[Unit]\nDescription=Send UDP Broadcast Service\nAfter=network.target\n\n[Service]\nExecStart=/usr/local/bin/send_ipaddr_broadcast.py\n\n[Install]\nWantedBy=multi-user.target\n\n```\n\n* 开启服务\n```bash\nsudo systemctl start send_ipaddr_broadcast.service\n```\n\n* 开机自启\n```bash\nsudo systemctl enable send_ipaddr_broadcast.service\n```\n\n## 4.测试\n\n* 打开网络调试助手\n\n* 选择UDP模式\n\n* 选择合适的本地主机地址（非127.0.0.1）\n* 输入本地主机端口7893\n* 点击开启按钮\n* 接收设置选择：ASCII模式\n\n![test](test.png)","tags":["RaspberryPi"]},{"title":"Win10系统下配置opencv库并在QT中使用","url":"/2023/08/06/Win10系统下配置opencv库并在QT中使用/","content":"\nOpenCV Qt Windows10\n\n1. 官网组装[https://opencv.org/releases/](https://opencv.org/releases/)下载Windows环境所使用的压缩包（包含源文件和编译好的库文件）\n\n2. 将压缩包解压到本地文件夹，如G:\\\n   \n   ![opencv_file_list](opencv_file_list.png)\n   \n3. 编辑WIndow系统环境变量，增加（G:\\opencv\\build\\x64\\vc15\\bin）\n\n4. qt新建界面应用工程，使用MSCV编译器。\n\n5. qt项目文件夹处右击，选择添加库。\n\n   ![qt_add_library](qt_add_library.png)\n\n6. 外部库，下一步；\n\n7. 库文件：G:/opencv/build/x64/vc15/lib/opencv_world345.lib；包含路径：G:/opencv/build/include；勾选debug版添加'd'；下一步，完成；软件会将配置信息添加到.Pro工程文件中；\n\n   ![qt_set_project](qt_set_project.png)\n\n8. 准备一张图片，注意图片名及路径仅可使用英文字符。如G:\\opencv\\demo.png\n\n9. 修改代码mainwindow.cpp，注意文件路径\n\n```c++\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/core/core.hpp>\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    cv::Mat image = cv::imread(\"G:/opencv/demo.png\");\n    cv::namedWindow(\"My Image\");\n    cv::imshow(\"window\", image);\n//    cv::waitKey(-1);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n```\n\n10. 断点调试\n\n点击Debug按钮开始调试，会有图片及界面弹出。增加断点验证调试功能是否正常。\n","tags":["OpenCV"]},{"title":"pyqt数值输入框与进度条联动","url":"/2023/08/06/pyqt数值输入框与进度条联动/","content":"\nQSlider QSpinBox QDoubleSpinBox\n\n## 1.背景\n\n1. QSpinBox/QDoubleSpinBox（数值输入框）：\n\n   使用`valuechange`信号，在修改数值的过程中会发送信号，如输入123，则会触发1、12、123三条信号。若是删除原有数据，产生的信号会更多。`editingFinished`在输入完成后鼠标离开控件（失去焦点）或按下回车才会触发信号。\n\n2. QSlider （进度条）：\n\n   使用`valuechange`信号，在滑块拖动过程中，信号将会被频繁发送。 如果是上位机通过串口向下位机发送指令，一般下位机（简单MCU做主控）无法响应高频率的指令。\t`released`信号只有在释放滑块时才会发送，但点击slider部件造成的滑块移动，并不会发送released信号，就造成当前滑块位置与实际参数不一致的BUG。\n\n\n\n## 2.控件联动和信号的产生\n\n1. 创建控件\n\n```python\n# 整数\nself.d_slider = QtWidgets.QSlider(self.xxx)\nself.d_spin_box = QtWidgets.QSpinBox(self.xxx)\n# 小数\nself.f_slider = QtWidgets.QSlider(self.xxx)\nself.f_slider = QtWidgets.QDoubleSpinBox(self.xxx)\n```\n\n\n\n2. double数值输入和整数进度条控件相互转换需特殊处理（此处固定为1个小数点）\n\n```python\ndef xx_sTb\n\tself.f_spin_box.setValue(self.f_slider.value() / 10)\n    \ndef xx_bTs\n\tself.f_slider.setValue(self.f_spin_box.value() * 10)\n```\n\n\n\n3. 实现输入框和进度条联动（信号和槽）\n\n```python\n# 整数直接相互设置\nself.d_slider.valueChanged.connect(self.d_spin_box.setValue)\nself.d_spin_box.valueChanged.connect(self.d_slider.setValue)\n\n#小数需通过函数转换\nself.f_slider.valueChanged.connect(self.xx_sTb)\nself.f_spin_box.valueChanged.connect(self.xx_bTs)\n```\n\n\n\n4. 槽函数\n\n```python\n# 槽函数\nself.event_list = [\n\tlambda: self._send_message(0), lambda: self._send_message(1)\n]\n\n# 具体操作内容\ndef _send_message(self, id: int):\n    if id == 0:\n        print(\"send0\")\n        buf = self.d_spin_box.value()  # 数值输入框的值 进度条仅为整数需放大和缩小\n    if id == 1:\n        print(\"send1\")\n        buf = self.f_spin_box.value()\n```\n\n\n\n5. 实现信号发出（信号和槽）\n\n```\n# \nself.d_slider.sliderReleased.connect(self.event_list[0])\nself.d_spin_box.editingFinished.connect(self.event_list[0])\n\nself.f_slider.sliderReleased.connect(self.event_list[1])\nself.f_spin_box.editingFinished.connect(self.event_list[1])\n\n```\n\n\n\n6. 以上实现了控件联动和信号的产生发送，但是开头提到的**滑块位置与实际参数不一致的BUG**没有解决\n\n\n\n## 3.解决滑块单机无信号的问题\n\n1. 安装事件过滤器\n\n```python\n# 为滑块安装过滤器\nself.d_slider.installEventFilter(self)\nself.f_slider.installEventFilter(self)\n```\n\n\n\n2. 重写事件过滤方法。将滑块的左键单击，修改为滑块释放信号\n\n```python\ndef eventFilter(self, a0: 'QObject', a1: 'QEvent') -> bool:\n    name = a0.objectName()\n    # 判断控件名称 防止与其他安装了过滤器的控件相互影响\n    if name.endswith(\"_slider\") or name.endswith(\"_dslider\"):\n        if a1.type() == a1.MouseButtonRelease and a1.button() == 1: # 判断左键\n            0.setSliderDown(True)  #模拟滑块的点击\n            a0.setSliderDown(False) #模拟滑块的点击\n            # 必需先按下后释放，才能触发sliderReleased信号\n    return False\n```\n","tags":["PyQt"]},{"title":"TheengsGateway应用指南","url":"/2023/08/06/TheengsGateway应用指南/","content":"\nTheengs Gateway Python\n\n## 1.Advanced users - Build and install\n\n1. 参考https://gateway.theengs.io/install/install.html#install-theengs-gateway-as-a-docker\n2. 若使用自己修改的TheengsDecoder，注意在setup.py文件中修改依赖包的版本。\n3. setup.py修改version版本号，例如`version=\"1.1.0\"`\n4. `__main__.py`调试项目，提示import失败，需将`from . import main`改为`from TheengsGateway import main`\n\n增加对串口的支持\n\n```python\n    async def serial_wr_loop(self) -> None:\n        async def read_from_serial(reader):\n            count = 0\n            self.running = True\n            while not self.stopped:\n                data = await reader.read(1000)\n                count += 1\n\n                logger.info(\n                    \"Received at `%s` from Serial: `%s`\",\n                    count,\n                    data,\n                )\n\n                data_json = {}\n                if 'None' in gw.serial_device:\n                    logger.error(\"gw.serial_device is None, please check\")\n                    self.stopped = True\n                elif 'YE600X' in gw.serial_device:\n                    # YE600X 设备调试 使用串口助手以十六进制方式发送测试数据 1e 5f 00 41 00 4b 00 e1 07 07 0c 08 0a 19 40 00 00 04 00\n                    try:\n                        data_str = bytes.decode(data, encoding='utf8')\n                        if data_str.find(\"CONNECTED\") >= 0:\n                            self.serial_mac = bytes.decode(data[data_str.find(\",\")+1:], encoding='utf8')\n                            self.serial_connect_status = \"online\"\n                            logger.info(\"serial device connected, mac: %s\", self.serial_mac)\n                        if data_str.find(\"DISCONN\") >= 0:\n                            self.serial_mac = bytes.decode(data[data_str.find(\",\")+1:], encoding='utf8')\n                            self.serial_connect_status = \"offline\"\n                            logger.info(\"serial device disconnected, mac: %s\", self.serial_mac)\n                    except:\n                        logger.info(\"serial read ascii data\")\n                    data_json[\"name\"] = \"YE600X\"\n                    data_json[\"mac\"] = self.serial_mac\n                    data_json[\"connect_status\"] = self.serial_connect_status\n                    data_json[\"manufacturerdata\"] = ''.join(['%02X' % b for b in data])\n                elif 'sps' in gw.serial_device:\n                    # sps 设备调试 使用串口助手以十六进制方式发送测试数据 af 09 7C 18 01 f9 9c 44 08\n                    data_json[\"manufacturerdata\"] = ''.join(['%02X' % b for b in data])\n                    data_json[\"id\"] = \"88:33:22:FF:44:77\"\n                    data_json[\"name\"] = \"sps\"\n                    data_json[\"rssi\"] = -15\n                else:\n                    logger.error(\"gw.serial_device is not defined, please check\")\n                    self.stopped = True\n\n                decoded_json = decodeBLE(json.dumps(data_json))  # 将python对象编码成Json字符串\n                if decoded_json is None:\n                    logger.info(\"serial decodeBLE return None\")\n                else:\n                    msg = decoded_json\n                    gw.publish(\n                        msg,\n                        gw.presence_topic,\n                    )\n            logger.error(\"serial read loop stopped\")\n            self.running = False\n\n        async def write_to_serial(writer):\n            self.running = True\n            while not self.stopped:\n                writer.write(b'off\\n')\n                await writer.drain()\n                await asyncio.sleep(2)\n            logger.error(\"serial write loop stopped\")\n            self.running = False\n        try:\n            reader, writer = await serial_asyncio.open_serial_connection(url=gw.serial_port, baudrate=115200)\n            task_1 = asyncio.create_task(read_from_serial(reader))\n            task_2 = asyncio.create_task(write_to_serial(writer))\n            await task_1\n            await task_2\n        except:\n            self.running = False\n            self.stopped = True\n            logger.error(\"serial %s port open failed, please check\", gw.serial_port)\n            \n            \ndef run(arg: str) -> None:\n    # 修改\n    thread = Thread(target=loop.run_forever, daemon=True)\n    thread.start()\n    asyncio.run_coroutine_threadsafe(gw.serial_wr_loop(), loop)\n```\n\n```python\ndef main() -> None:\n    # 增加串口端口号和目标设备类型的选项\n    parser.add_argument(\n        \"-sp\", \"--serial_port\", dest=\"serial_port\", type=str, help=\"Serial port\"\n    )\n    parser.add_argument(\n        \"-si\", \"--serial_device_id\", dest=\"serial_device\", type=str, help=\"Serial device id, need check <TheengsDecoder/src/devices/list>\"\n    )\n    # 将 serial_port  serial_device 加入配置文件的读写，并传递给 Gateway\n```\n\n","tags":["IoT"]},{"title":"TheengsDecoder应用指南","url":"/2023/08/06/TheengsDecoder应用指南/","content":"\nTheengs Decoder Python\n\n## 1.项目搭建\n\n1. clone工程\n2. 将下载arduino_json项目并复制到src\\arduino_json文件夹中\n3. 如果是python使用，查看https://decoder.theengs.io/use/python.html#dependencies (windows 下不用apt-get install cmake指令，在pip install . 指令脚本会自动安装依赖)\n4. 在src\\device\\中增加新的硬件解码规则，device.h中增加头文件，并加入列表\n5. decoder.h中将新硬件加入列表（BLE_ID_MAX的前面）\n6. 注意每次修改完解码规则文件，必须重新编译(例如python下使用pip install .)生效后方可测试\n\n## 2.测试脚本\n\n```python\nimport json\nfrom TheengsDecoder import decodeBLE as dble\n\ndata_json = {\"manufacturerdata\": \"1E5F0041004B00E107070C080A194000000400\", \"name\": \"YE600X\"}\n# data_json = {\"manufacturerdata\": \"af097C1801f99c4408\", \"name\": \"sps\"}\ndata = dble(json.dumps(data_json))\nprint(data)\n```\n\n## 3.新增解码规则\n\nYE600X_json.h\n\n被`/*R\"\"\"\"(`注释的代码要符合json格式\n\n删除空格回车，将`\"`前增加转义符`\\`\n\n索引编号从0开始，每个字符占一个；因为每个字符都是分开计算的，故位编号范围0-3\n\n```\nconst char* _YE600X_json = \"{\\\"brand\\\":\\\"YUWELL\\\",\n/*R\"\"\"\"(            //血压\n{\n   \"brand\":\"YUWELL\",                   //品牌：鱼跃\n   \"model\":\"BloodPressureMeters\",      //型号：血压仪\n   \"model_id\":\"YE600X\",                //型号ID：YE600X\n   \"cidc\":false,                       //起始字节不符合Bluetooth标准\n   \"condition\":[\"manufacturerdata\", \"=\", 38, \"&\", \"name\", \"index\", 0, \"YE600X\"],  //条件：name = YE600X\n   \"properties\":{\n      \"pressure_unit\":{\n         \"decoder\":[\"bit_static_value\", \"manufacturerdata\", 1, 0, \"mmHg\", \"kPa\"]  //血压单位： 第0字节 第0位  true：mmHg false：kpa\n      },\n      \"systolic_pressure\":{\n         \"decoder\":[\"value_from_hex_data\", \"manufacturerdata\", 2, 4, true]\n      }\n    }\n}\n\nconst char* _YE600X_json_props = \"{\\\"properties\\\":\n/*R\"\"\"\"(\n{\n   \"properties\":{\n      \"pressure_unit\":{\n         \"unit\":\"string\",\n         \"name\":\"contact\"\n      },\n      \"systolic_pressure\":{\n         \"unit\":\"string\",\n         \"name\":\"contact\"\n      }\n    }\n}\n```\n","tags":["IoT"]},{"title":"Qt创建C++动态库DLL","url":"/2023/08/06/Qt创建CPP动态库DLL/","content":"\n## 1.创建C++动态库DLL\n\n为了提高代码复用性，实现模块化开发，我们通常会对一些常用函数进行封装，通过调用动态链接库的方法实现，Qt自生便能构建共享库。\n\n## 1.1新建共享库工程\n\n* 新建工程，选择动态库，命名为DynamicLibrary，实现一个简单的方法(method) : int test()\n\nDynamicLibrary_global.h\n\n```C++\n#ifndef DYNAMICLIBRARY_GLOBAL_H\n#define DYNAMICLIBRARY_GLOBAL_H\n\n#include <QtCore/qglobal.h>\n\n#if defined(DYNAMICLIBRARY_LIBRARY)\n#  define DYNAMICLIBRARY_EXPORT Q_DECL_EXPORT\n#else\n#  define DYNAMICLIBRARY_EXPORT Q_DECL_IMPORT\n#endif\n\n#endif // DYNAMICLIBRARY_GLOBAL_H\n```\n\n\n\ndynamiclibrary.h\n\n```c++\n#ifndef DYNAMICLIBRARY_H\n#define DYNAMICLIBRARY_H\n\n#include \"DynamicLibrary_global.h\"\n\nclass DYNAMICLIBRARY_EXPORT DynamicLibrary\n{\npublic:\n    DynamicLibrary();\n    int test();\n};\n\n#endif // DYNAMICLIBRARY_H\n```\n\ndynamiclibrary.cpp\n\n```C++\n#include \"dynamiclibrary.h\"\n#include <QDebug>\n\nDynamicLibrary::DynamicLibrary()\n{\n}\n\nint DynamicLibrary::test()\n{\n    qDebug() << \"Hello Qt5\";\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum = sum + i;\n    }\n    qDebug() << sum;\n    return sum;\n}\n```\n\n* Build(Debug) 得到动态库`DynamicLibrary.dll`\n\n## 1.2调用动态库\n\n* 新建一个控制台工程LoadDynamic，用于测试调用前面构建的动态库dll\n* 导入相关头文件，先复制头文件至工程路径下(DynamicLibrary_global.h  dynamiclibrary.h)，然后项目单击右键添加现有文件。\n* 链接库，配置pro文件，增加动态链接库的路径`LIBS += xxx\\debug\\DynamicLibrary.dll`\n* Build(Debug) 得到可执行文件\n* 运行可执行文件时需要系统找到对应的动态链接库，可以将原来生成的动态链接库拷贝至可执行文件同级目录下\n* 其他依赖文件：开始-Qt-Qt命令行，输入windeployqt xxx\\debug\\LoadDynamic.exe\n* 可执行文件路径处输入cmd，打开命令行输入LoadDynamic.exe运行\n* ldd或depends检查依赖库情况","tags":["Qt"]},{"title":"ESP-USB-Bridge-JTAG-Debug","url":"/2022/05/08/ESP-USB-Bridge-JTAG-Debug/","content":"\n## 1.Create Project\n\nOpen VSCode\n\n<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>    `ESP-IDF: Show Examples Projects`  `hello_world`\n\n**Create project using example hello_world**\n\n## 2.Setup\n\nSelect port to use (COMx)\n\nset device targete\n\nBuild project\n\nSelect flash method (JTAG)\n\n![image-20220508171334927](image-20220508171334927.png)\n\n![image-20220508171702904](image-20220508171702904.png)\n\nedit file: `.vscode/settings.json`  (注意修改**COMx**)\n\n``` json\n{\n  \"C_Cpp.intelliSenseEngine\": \"Tag Parser\",\n  \"idf.portWin\": \"COMx\",\n  \"idf.openOcdConfigs\": [\n    \"interface/esp_usb_bridge.cfg\",\n    \"target/esp32.cfg\"\n  ],\n  \"idf.flashType\": \"JTAG\"\n}\n```\n\n<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>  `ESP-IDF: OpenOCD Manager`  `start openocd`\n\n![image-20220508173310006](image-20220508173310006.png)\n\n[.vscode/settings.json](https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/DEBUGGING.md)\n\n``` c\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"GDB\",\n      \"type\": \"cppdbg\",\n      \"request\": \"launch\",\n      \"MIMode\": \"gdb\",\n      \"miDebuggerPath\": \"${command:espIdf.getXtensaGdb}\",\n      \"program\": \"${workspaceFolder}/build/${command:espIdf.getProjectName}.elf\",\n      \"windows\": {\n        \"program\": \"${workspaceFolder}\\\\build\\\\${command:espIdf.getProjectName}.elf\"\n      },\n      \"cwd\": \"${workspaceFolder}\",\n      \"environment\": [{ \"name\": \"PATH\", \"value\": \"${config:idf.customExtraPaths}\" }],\n      \"setupCommands\": [\n        { \"text\": \"target remote :3333\" },\n        { \"text\": \"set remote hardware-watchpoint-limit 2\"},\n        { \"text\": \"mon reset halt\" },\n        { \"text\": \"thb app_main\" },\n        { \"text\": \"flushregs\" }\n      ],\n      \"externalConsole\": false,\n      \"logging\": {\n        \"engineLogging\": true\n      }\n    }\n  ]\n}\n```\n\n## 3.Flash And Debug\n\nflash\n\n![image-20220508174242796](image-20220508174242796.png)\n\n<kbd>F5</kbd>  \n\n   *Try more times*\n\n![image-20220508174435026](image-20220508174435026.png)\n\nOther\n\n  [https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/debugging.md](https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/debugging.md)\n\n\n","tags":["ESP32"]},{"title":"ESP-USB-Bridge","url":"/2022/05/02/ESP-USB-Bridge/","content":"\n[https://github.com/espressif/esp-usb-bridge](https://github.com/espressif/esp-usb-bridge)\n\n## 1.Clone\n\n``` sh\ngit clone --depth 1 https://github.com/espressif/esp-usb-bridge.git\n```\n\n## 2.VSCode\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> `ESP-IDF: Open ESP-IDF Terminal`\n\n1. Config\n\n``` sh\nidf.py menuconfig\n```\n\ndown: <kbd>J</kbd>   up:<kbd>K</kbd> \n\nsettings are in the \"Bridge Configuration\" sub-menu, swap  TDO/TDI target pin num.\n\n2. Build\n\n``` sh\nidf.py build\n```\n\n3. Flash\n\n``` sh\nidf.py -p PORT flash monitor\n```\n\nPORT is the serial port created by an USB-to-UART chip\n\nTips: set boot load mode\n\n![Step](set-boot-step.png)\n\n4. Reboot\n\n## 3.Install Driver\n\nWindows Device manager\n\n![device manager 0](device-manager-0.png)\n\ninstall driver\n\n[UsbDriverTool](https://visualgdb.com/UsbDriverTool/)\n\n![install driver.png](install-driver.png)\n\ninstall success\n\n![device manager 1](device-manager-1.png)\n\n## 4.Connect Target\n\n1. connect target mcu\n\n![concept](concept.png)\n\n2. set target mcu download mode\n\n![target mcu download mode](target-mcu-download-mode.png)\n\n3. OpenOCD connect ESP32-WROVER-E\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> ESP-IDF: Open ESP-IDF Terminal\n\n``` sh\nopenocd.exe -f interface/esp_usb_bridge.cfg -f target/esp32.cfg\n```\n\n![connect esp32 wrover](connect-esp32-wrover.png)\n\n3. use jtag flash\n\n![use jtag flash](use-jtag-flash.png)\n\n4. use serial\n\n   * Select Port  (COMx)\n\n   * ESP-IDF Monitor device\n\n   * reboot target mcu\n\n![serial test](serial-test.png)\n\n\n","tags":["ESP32"]},{"title":"ESP32 Windows VSCode IDE","url":"/2022/05/02/ESP32-Window-VSCode/","content":"\n[ESP-IDF Document](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html)\n\n##  1.VSCode\n\n[Download](https://code.visualstudio.com/download) and install  Visual Studio Code\n\n## 2.VSCode Extension\n\n1. [Espressif IDF](https://marketplace.visualstudio.com/items?itemName=espressif.esp-idf-extension)\n2. [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)\n3. [Native Debug](https://marketplace.visualstudio.com/items?itemName=webfreak.debug)\n\n## 3.Install ESP-IDF\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd>  ESP-IDF: Configure ESP-IDF extension\n\nChoose installation method (EXPRESS / ADVANCED / USE EXISTING SETUP)\n\n## 4.Creat Project\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> ESP-IDF: Show Examples Projects\n\nget-started >hello_world > Create project using example hello_world\n\n1. Select Port\n2. Set Espressif device target\n3. Build\n4. Select flash method\n5. flash device\n6. Monitor device\n","tags":["ESP32"]},{"title":"FR-CS80 FVD Modbus Communication","url":"/2022/04/03/FR-CS80-VFD-Modbus/","content":"\nMITSUBISHI 三菱 VFD 变频器 Modbus 通讯 RS485\n\n## 1.供电\n\n![image-20220329235106376](image-20220329235106376.png)\n\n## 2.通讯接线\n\n![image-20220329235152416](image-20220329235152416.png)\n\n![image-20220329235832966](image-20220329235832966.png)\n\n![image-20220330000913954](image-20220330000913954.png)\n\n| USB-RS422 | T-568B | VFD     |\n| --------- | ------ | ------- |\n| T+        | G/   3 | RDA(R+) |\n| T-        | G    6 | RDB(R-) |\n| R+        | B/   5 | SDA(T+) |\n| R-        | B    4 | SDB(T-) |\n\n## 3.变频器参数设置\n\n首先恢复出厂设置\n\n![image-20220330001346543](image-20220330001346543.png)\n\n\n\n按照表格依次设置\n\n| Pr.  | 名称                 | 设定值 | 内容                                        |\n| ---- | -------------------- | ------ | ------------------------------------------- |\n| 117  | PU 通讯站号          | 1      | 从机地址                                    |\n| 118  | PU 通讯速度          | 192    | 19200pbs                                    |\n| 120  | PU 通讯奇偶校验      | 2      | 偶数校验                                    |\n| 122  | PU 通讯校验时间间隔  | 9999   | 不进行通讯断线检测                          |\n| 79   | 运行模式选择         | 0      | 网络运行模式（可切换PU/网络）               |\n| 340  | 通讯启动模式选择     | 10     | 网络运行模式（可切换PU/网络）               |\n| 342  | 通讯 EEPROM 写入选择 | 1      | PU接口写入参数仅限RAM（防止频繁写入EEPROM） |\n| 549  | 协议选择             | 1      | MODBUS RTU 协议                             |\n\n说明：\n\nmodbus通讯变频器必须工作在**网络运行模式**下（PU模式下数据可读取但无法写入）\n\n通讯调试阶段建议增加奇/偶校验（测试中遇到USB-422转换模块在无校验情况下通讯失败的情况）\n\n重启变频器\n\nPU、EXT 闪烁：网络运行模式时闪烁\n\n## 4.上位机软件（Modbus Poll）设置\n\n通讯接口（F3）\n\n![image-20220330003925711](image-20220330003925711.png)\n\n寄存器读取（F8）\n\n40009\n\n![image-20220402212121666](image-20220402212121666.png)\n\n多段寄存器读取 File New\n\n20201\n\n![image-20220402212313037](image-20220402212313037.png)\n\n寄存器写入\n\n![image-20220402212557637](image-20220402212557637.png)\n\n正转：0x0002\n\n反转：0x0004\n\n软件支持按位改变\n\n![image-20220402212806410](image-20220402212806410.png)\n\n查看通讯log数据\n\n![image-20220402213119377](image-20220402213119377.png)\n","tags":["变频器"]},{"title":"Stm32F407vet6_qboot_Ymodem","url":"/2022/03/05/Stm32F407vet6-qboot-Ymodem/","content":"\nstm32f407vet6 qboot Ymodem PuTTY\n\n## 1.qboot project\n\n---\n\n1. enable onchip and w25qxx flash\n\n2. add qboot package\n\n![image-20220305212321866](image-20220305212321866.png)\n\n3. build download\n\n![image-20220305212353411](image-20220305212353411.png)\n\n\n\n## 2.app project\n\n---\n\n1. enable onchip and w25qxx flash\n\n2. add ota_downloader\n\n   ![image-20220305213051752](image-20220305213051752.png)\n\n3. edit link.lds\n\n   0x20000 = 128k          384 = 512-128\n\n   ![image-20220305213650986](image-20220305213650986.png)\n\n3. build and download\n\n   qboot jump app\n\n   ![image-20220305214540437](image-20220305214540437.png)\n\n4. change main.c\n\n```c\n#include <rtthread.h>\n#include <board.h>\n\n#define DBG_TAG \"main\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\nint main(void)\n{\n    int count = 1;\n\n    while (count++)\n    {\n        //LOG_D(\"Hello RT-Thread!\");\n        rt_thread_mdelay(1000);\n    }\n\n    return RT_EOK;\n}\n\n#define RT_APP_PART_ADDR    0x08020000\n#define NVIC_VTOR_MASK      0xFFFFFF80\nstatic int app_vtor__reconfig(void)\n{\n    SCB->VTOR = RT_APP_PART_ADDR & NVIC_VTOR_MASK;\n\n    return 0;\n}\nINIT_BOARD_EXPORT(app_vtor__reconfig);\n\n```\n\n6. build download\n\n   qboot jump app success\n\n   ![image-20220305215300979](image-20220305215300979.png)\n\n7. **\\packages\\ota_downloader-latest\\tools\\ota_packager\\rt_ota_packaging_tool.exe**\n\n   ![image-20220305215722299](image-20220305215722299.png)\n\n8. ExtraPuTTY (PuTTY Session Manager)\n\n   ![image-20220305220535007](image-20220305220535007.png)\n\n9. Ymodem Send\n\n   ![image-20220305220451993](image-20220305220451993.png)\n\n10. System restart\n\n    Qboot erase partition app\n\n    Release firmware from download to app\n\n    Jump to applicaton \n\n    ![image-20220305220906216](image-20220305220906216.png)\n","tags":["STM32"]},{"title":"Stm32F407vet6-onchip-w25qxx-flash","url":"/2022/03/05/Stm32F407vet6-onchip-w25qxx-flash/","content":"\n使用w25qxx flash\n\n## 1.CubeMx\n\n1. new project\n\nchange **drivers/board.h**\n\n```c\n/*#define BSP_USING_ON_CHIP_FLASH*/\n#define BSP_USING_ON_CHIP_FLASH\n```\n\n2. RT-Thread Setting\n\nadd packages\n\n![image-20220304203615948](image-20220304203615948.png)\n\n3. onchip flash *Tisp*\n\n![stm32f4_onchip_flash_map](stm32f4_onchip_flash_map.png)\n\n4. generated by rt-rhread **drivers/drv_flash_f4.c**\n\n![image-20220304205249004](image-20220304205249004.png)\n\n5. new source file **applications/fal_cfg.h**\n\n```c\n#ifndef _FAL_CFG_H_\n#define _FAL_CFG_H_\n\n#include <rtconfig.h>\n#include <board.h>\n\n//#define NOR_FLASH_DEV_NAME             FAL_USING_NOR_FLASH_DEV_NAME\n\n//STM32F4VET6 512K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (3*128*1024)\n/*STM32F4xxx  1024K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (7*128*1024)\n */\n\n#define STM32_FLASH_START_ADRESS_16K    (STM32_FLASH_START_ADRESS)\n#define STM32_FLASH_START_ADRESS_64K    (STM32_FLASH_START_ADRESS_16K+FLASH_SIZE_GRANULARITY_16K)\n#define STM32_FLASH_START_ADRESS_128K   (STM32_FLASH_START_ADRESS_64K+FLASH_SIZE_GRANULARITY_64K)\n\n/* ===================== Flash device Configuration ========================= */\nextern const struct fal_flash_dev stm32_onchip_flash_16k;\nextern const struct fal_flash_dev stm32_onchip_flash_64k;\nextern const struct fal_flash_dev stm32_onchip_flash_128k;\nextern struct fal_flash_dev nor_flash0;\n\n/* flash device table */\n#define FAL_FLASH_DEV_TABLE                                          \\\n{                                                                    \\\n    &stm32_onchip_flash_16k,                                         \\\n    &stm32_onchip_flash_64k,                                         \\\n    &stm32_onchip_flash_128k,                                        \\\n    /*&nor_flash0,       */                                          \\\n}\n/* ====================== Partition Configuration ========================== */\n#ifdef FAL_PART_HAS_TABLE_CFG\n//boot = (onchip_flash_16k + onchip_flash_64k) = 128k\n//dev name ===>> stm32_onchip_flash_16k\n/* partition table */\n#define FAL_PART_TABLE                                                               \\\n{                                                                                    \\\n    {FAL_PART_MAGIC_WORD,        \"bl\", \"onchip_flash_16k\",  0,  FLASH_SIZE_GRANULARITY_16K,  0}, \\\n    {FAL_PART_MAGIC_WORD,      \"bl64\", \"onchip_flash_64k\",  0,  FLASH_SIZE_GRANULARITY_64K,  0}, \\\n    {FAL_PART_MAGIC_WORD,       \"app\", \"onchip_flash_128k\", 0,  FLASH_SIZE_GRANULARITY_128K, 0}, \\\n/*    {FAL_PART_MAGIC_WORD, \"easyflash\", NOR_FLASH_DEV_NAME,          0,    512*1024, 0},*/ \\\n/*    {FAL_PART_MAGIC_WORD, \"download\", NOR_FLASH_DEV_NAME,    512*1024,    512*1024, 0},*/ \\\n/*    {FAL_PART_MAGIC_WORD,     \"file\", NOR_FLASH_DEV_NAME, 1*1024*1024, 7*1024*1024, 0},*/ \\\n}\n#endif /* FAL_PART_HAS_TABLE_CFG */\n\n#endif /* _FAL_CFG_H_ */\n```\n\n\n\n6. new  source file **applications/usr_flash.c**\n\n```c\n#include <rtthread.h>\n#include \"fal.h\"\n\nstatic int usr_flash_init(void)\n{\n    fal_init();\n    return RT_EOK;\n}\n\nINIT_ENV_EXPORT(usr_flash_init);\n```\n\n7. Build + Download\n\nPuTTY\n\n![image-20220304213533067](image-20220304213533067.png)\n\n8. debug\n\n![image-20220304214034449](image-20220304214034449.png)\n\n\n\n## 2.W25Q64\n\n---\n\n1. change **drivers/board.h**\n\n```c\n/*#define BSP_USING_SPI1*/\n#define BSP_USING_SPI2\n/*#define BSP_USING_SPI3*/\n```\n\n2. RT-Thread Setting\n\n![image-20220304214418575](image-20220304214418575.png)\n\n![image-20220304223001519](image-20220304223001519.png)\n\n3. CubeMX Setting\n\nenable spi bus\n\n4. change **applications/usr_flash.c**\n\n```c\n#include <rtthread.h>\n#include \"drv_spi.h\"\n#include \"spi_flash_sfud.h\"\n#include \"fal.h\"\n\nstatic int usr_flash_init(void)\n{\n    rt_hw_spi_device_attach(\"spi2\", \"spi20\", GPIOE, GPIO_PIN_3);\n    if (RT_NULL == rt_sfud_flash_probe(\"norflash0\", \"spi20\")) {\n        return RT_ERROR;\n    }\n\n    fal_init();\n\n    return RT_EOK;\n}\n\nINIT_ENV_EXPORT(usr_flash_init);\n```\n\n5. copy file from **packages/fal-v0.5.0/samples/porting/fal_flash_sfud_port.c** to **applications/fal_flash_sfud_port.c**\n\n6. change fal_cfg.h\n\n```c\n#ifndef _FAL_CFG_H_\n#define _FAL_CFG_H_\n\n#include <rtconfig.h>\n#include <board.h>\n\n#define NOR_FLASH_DEV_NAME             FAL_USING_NOR_FLASH_DEV_NAME\n\n//STM32F4VET6 512K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (3*128*1024)\n/*STM32F4xxx  1024K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (7*128*1024)\n */\n\n#define STM32_FLASH_START_ADRESS_16K    (STM32_FLASH_START_ADRESS)\n#define STM32_FLASH_START_ADRESS_64K    (STM32_FLASH_START_ADRESS_16K+FLASH_SIZE_GRANULARITY_16K)\n#define STM32_FLASH_START_ADRESS_128K   (STM32_FLASH_START_ADRESS_64K+FLASH_SIZE_GRANULARITY_64K)\n\n/* ===================== Flash device Configuration ========================= */\nextern const struct fal_flash_dev stm32_onchip_flash_16k;\nextern const struct fal_flash_dev stm32_onchip_flash_64k;\nextern const struct fal_flash_dev stm32_onchip_flash_128k;\nextern struct fal_flash_dev nor_flash0;\n\n/* flash device table */\n#define FAL_FLASH_DEV_TABLE                                          \\\n{                                                                    \\\n    &stm32_onchip_flash_16k,                                         \\\n    &stm32_onchip_flash_64k,                                         \\\n    &stm32_onchip_flash_128k,                                        \\\n    &nor_flash0,                                                     \\\n}\n/* ====================== Partition Configuration ========================== */\n#ifdef FAL_PART_HAS_TABLE_CFG\n//boot = (onchip_flash_16k + onchip_flash_64k) = 128k\n//dev name ==>> stm32_onchip_flash_16k\n/* partition table */\n#define FAL_PART_TABLE                                                               \\\n{                                                                                    \\\n    {FAL_PART_MAGIC_WORD,        \"bl\", \"onchip_flash_16k\",  0,  FLASH_SIZE_GRANULARITY_16K,  0}, \\\n    {FAL_PART_MAGIC_WORD,      \"bl64\", \"onchip_flash_64k\",  0,  FLASH_SIZE_GRANULARITY_64K,  0}, \\\n    {FAL_PART_MAGIC_WORD,       \"app\", \"onchip_flash_128k\", 0,  FLASH_SIZE_GRANULARITY_128K, 0}, \\\n    {FAL_PART_MAGIC_WORD, \"easyflash\", NOR_FLASH_DEV_NAME,          0,     512*1024, 0}, \\\n    {FAL_PART_MAGIC_WORD,  \"download\", NOR_FLASH_DEV_NAME,    512*1024,    512*1024, 0}, \\\n    {FAL_PART_MAGIC_WORD,      \"file\", NOR_FLASH_DEV_NAME, 1*1024*1024, 7*1024*1024, 0}, \\\n}\n#endif /* FAL_PART_HAS_TABLE_CFG */\n\n#endif /* _FAL_CFG_H_ */\n```\n\n7. Build + Download\n\n8. debug\n\n## 3.fal test\n\n![image-20220304225042638](image-20220304225042638.png)","tags":["STM32"]},{"title":"Stm32F407_PWM_External_Sync","url":"/2022/01/18/Stm32F407-PWM-External-Sync/","content":"\n## 1.PWM与外部触发信号同步\n\n---\n\n1. new progect\n\n2. CubeMX Setting\n\n   * RCC->Cystal\n\n   * SYS->Serial Wire\n\n   * Clock Configuration->168\n\n   * TIM1\n\n     ![image-20220118205730219](image-20220118205730219.png)\n\n     ![image-20220118205737972](image-20220118205737972.png)\n\n     ![image-20220118205747601](image-20220118205747601.png)\n\n     ![image-20220118205752456](image-20220118205752456.png)\n\n     ![image-20220118205757553](image-20220118205757553.png)\n\n   * Save\n\n## 2.Code\n\n---\n\n```c\nint main(void)\n{\n  /* USER CODE BEGIN 1 */\n\n  /* USER CODE END 1 */\n\n  /* MCU Configuration--------------------------------------------------------*/\n\n  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */\n  HAL_Init();\n\n  /* USER CODE BEGIN Init */\n\n  /* USER CODE END Init */\n\n  /* Configure the system clock */\n  SystemClock_Config();\n\n  /* USER CODE BEGIN SysInit */\n\n  /* USER CODE END SysInit */\n\n  /* Initialize all configured peripherals */\n  MX_GPIO_Init();\n  MX_TIM1_Init();\n  /* USER CODE BEGIN 2 */\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);\n  /* USER CODE END 2 */\n\n  /* Infinite loop */\n  /* USER CODE BEGIN WHILE */\n  while (1)\n  {\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n  }\n  /* USER CODE END 3 */\n}\n```\n\n\n## 3.Test\n\n---\n\n![image-20220118212029035](image-20220118212029035.png)\n\n![image-20220118212038552](image-20220118212038552.png)\n\n","tags":["STM32"]},{"title":"Stm32F407_PWM_Master_Slave","url":"/2022/01/18/Stm32F407-PWM-Master-Slave/","content":"\n## 1.概述\n\n使用STM32主定时器+从定时器实现产生可控数量的PWM脉冲\n\n## 2.创建工程\n\n1. new progect \n\n2. CubeMX Setting\n\n  * RCC->Crystal\n\n  * SYS->Serial Wire\n\n  * Clock Configuration->168\n\n  * TIM4\n\n    ![image-20220118201958020](image-20220118201958020.png)\n\n    ![image-20220118202025867](image-20220118202025867.png)\n\n    ![image-20220118202048425](image-20220118202048425.png)\n\n  * TIM2\n\n    ![image-20220118202135289](image-20220118202135289.png)\n\n    ![image-20220118202142804](image-20220118202142804.png)\n\n    ![image-20220118202148330](image-20220118202148330.png)\n\n    ![image-20220118203457549](image-20220118203457549.png)\n\n  * Save\n\n## 3.Code\n\n---\n\n1. main.c\n\n   ```c\n   /* USER CODE BEGIN 0 */\n   void generate_pulse(uint32_t value)\n   {\n   \tif(!value)\n   \t\treturn;\n   \t__HAL_TIM_SET_AUTORELOAD(&htim2,value-1); //设置要输出的PWM脉冲\n   \tHAL_TIM_Base_Start_IT(&htim2);             //启动从定时器\n   \t__HAL_TIM_SET_COUNTER(&htim4, 0);\n   \tHAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);  //启动主定时器PWM输出\n   }\n   \n   void  HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n   {\n       if(htim == &htim2)\n       {\n           if(__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_CC2) != RESET)  //判断是否触发中断\n           {\n               __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_CC2);      //清除中断标志\n               HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_2);   //关闭主定时器\n               HAL_TIM_Base_Stop_IT(&htim2);         //关闭从定时器\n           }\n       }\n   }\n   /* USER CODE END 0 */\n   \n   int main(void)\n   {\n     /* USER CODE BEGIN 1 */\n   \n     /* USER CODE END 1 */\n   \n     /* MCU Configuration--------------------------------------------------------*/\n   \n     /* Reset of all peripherals, Initializes the Flash interface and the Systick. */\n     HAL_Init();\n   \n     /* USER CODE BEGIN Init */\n   \n     /* USER CODE END Init */\n   \n     /* Configure the system clock */\n     SystemClock_Config();\n   \n     /* USER CODE BEGIN SysInit */\n   \n     /* USER CODE END SysInit */\n   \n     /* Initialize all configured peripherals */\n     MX_GPIO_Init();\n     MX_TIM2_Init();\n     MX_TIM4_Init();\n     /* USER CODE BEGIN 2 */\n   \n     /* USER CODE END 2 */\n   \n     /* Infinite loop */\n     /* USER CODE BEGIN WHILE */\n     while (1)\n     {\n       /* USER CODE END WHILE */\n   \n       /* USER CODE BEGIN 3 */\n   \tgenerate_pulse(10);\n   \tHAL_Delay(1000);\n     }\n     /* USER CODE END 3 */\n   }\n   ```\n\n   ## 4.Test\n\n   ![image-20220118202840364](image-20220118202840364.png)","tags":["STM32"]},{"title":"Stm32F407-ADC-DMA","url":"/2021/11/12/Stm32F407-ADC-DMA/","content":"\nstm32 ADC DMA rt-thread studio\n\n## 1.Rt-Thrad Studio\n\n---\n\n![image-20211112222940162](image-20211112222940162.png)\n\n## 2.CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)\n2. System Core >> SYS >> Debug(选择调试接口)\n3. Connectivity >> USART3 >> Asynchronous(用于finsh命令行)\n4. Analog >> ADC1 >>\n\nParameter Settings\n\n![image-20211112224235969](image-20211112224235969.png)\n\n![image-20211112224811725](image-20211112224811725.png)\n\n5. Analog >> ADC1 >> DMA Settings\n\n![image-20211112233043884](image-20211112233043884.png)\n\n6. Clock Configuration(配置时钟)  HCLK >> 168 >> Enter\n\n![image-20211111212633234](image-20211111212633234.png)\n\n7. GENERATE COED (default seting)\n\n![image-20211112225130880](image-20211112225130880.png)\n\n## Code\n\n---\n\n1. applications/main.c\n\n```c\n#include <rtthread.h>\n\n#define DBG_TAG \"main\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\nextern void usr_board_init(void);\nextern uint16_t read_adc_value(uint8_t channel);\n\nint main(void)\n{\n    int count = 1;\n\n    usr_board_init();\n\n    while (count++)\n    {\n        LOG_D(\"Hello RT-Thread!\");\n        rt_kprintf(\"PA3_adc = %d   \", read_adc_value(0));\n        rt_kprintf(\"PA4_adc = %d   \", read_adc_value(1));\n        rt_kprintf(\"PA5_adc = %d   \", read_adc_value(2));\n        rt_kprintf(\"PA6_adc = %d   \", read_adc_value(3));\n        rt_kprintf(\"\\n\");\n        rt_thread_mdelay(1000);\n    }\n\n    return RT_EOK;\n}\n```\n\n2. cubemx/Src/main.c\n\n```c\n/* USER CODE BEGIN 0 */\n\n#define ADC_CHANNEL_SUM         4\n#define ADC_BUFF_LOOP           30\nuint16_t adc_dma_value[ADC_CHANNEL_SUM * ADC_BUFF_LOOP];\n\nvoid usr_board_init(void)\n{\n    MX_DMA_Init();\n    MX_ADC1_Init();\n    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&adc_dma_value, ADC_CHANNEL_SUM * ADC_BUFF_LOOP);\n}\n\nuint16_t read_adc_value(uint8_t channel)\n{\n    if (channel < ADC_CHANNEL_SUM) {\n        return adc_dma_value[channel];\n    }\n    return 0;\n}\n/* USER CODE END 0 */\n\n/**\n  * Enable DMA controller clock\n  */\nstatic void MX_DMA_Init(void)\n{\n\n  /* DMA controller clock enable */\n  __HAL_RCC_DMA2_CLK_ENABLE();\n\n  /* DMA interrupt init */\n  /* DMA2_Stream0_IRQn interrupt configuration */\n  //HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);\n  //HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);\n\n}\n```\n\n## 3.Build && Test\n\nPA3_adc\n\n![image-20211112233634255](image-20211112233634255.png)\n\n---\n","tags":["STM32"]},{"title":"Stm32F407_W25Q64_easyFlash","url":"/2021/11/11/Stm32F407-W25Q64-easyFlash/","content":"\nstm32 flash w25q64 easyFlash rt-thread studio\n\n## 1.RT-Thread Studio\n\n1. new project\n\n![image-20211111213804740](image-20211111213804740.png)\n\n## 2.CubeMX Settings\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)  \n2. System Core >> SYS >> Debug(选择调试接口)   \n3. Connectivity >> USART3 >> Asynchronous(用于finsh命令行)  \n4. Connectivity >> SPI2 >> Full-Dupex Master(Flash W25Q64)\n\n![image-20211111212434054](image-20211111212434054.png)\n\n5. Clock Configuration(配置时钟)\n\n   HCLK >> 168  >> Enter\n\n![image-20211111212633234](image-20211111212633234.png)\n\n6. GENERATE COED (default seting)\n\n![image-20211111212753066](image-20211111212753066.png)\n\n![image-20210630224307585](image-20210630224307585.png)\n\n## 3.RT-Thread Setting\n\n1. Packages >> add >> EasyFlash\n\n![image-20211111234323900](image-20211111234323900.png)\n\n2. Drivers >> SPI\n\n3. Drivers >> SPI >> SFUD\n\n   ![image-20211111234429187](image-20211111234429187.png)\n\n## 4.Code\n\n1. *drivers/board.h*\n\n```c\n#define BSP_USING_UART3\n#define BSP_UART3_TX_PIN       \"PD8\"\n#define BSP_UART3_RX_PIN       \"PD9\"\n\n#define BSP_USING_SPI2\n```\n\n2. *new source file*\n\n   applications/usr_flash.c   (change cs pin and bus name)\n\n```c\n#include <rtthread.h>\n#include <drv_spi.h>\n#include \"spi_flash.h\"\n#include \"spi_flash_sfud.h\"\n\nrt_spi_flash_device_t w25q64;\n\nstatic int rt_hw_spi_flash_with_sfud_init(void)\n{\n    rt_hw_spi_device_attach(\"spi2\", \"spi20\", GPIOE, GPIO_PIN_3);\n\n    /* init w25q64 */\n    if (w25q64 == rt_sfud_flash_probe(\"w25q64\", \"spi20\"))\n    {\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(rt_hw_spi_flash_with_sfud_init);\n```\n\n3. copy file \n\n   packages\\EasyFlash-v4.1.0\\ports\\ef_sfud_port.c  >>  applications/usr_flash.c\n\n## 5.Build && Test\n\n   ![image-20211112221002533](image-20211112221002533.png)\n\n","tags":["STM32"]},{"title":"Stm32F407_USB_OTG_HS","url":"/2021/07/01/Stm32F407-USB-OTG-HS/","content":"\nusb-otg-hs u-disk rt-thread studio\n\n[github progect](https://github.com/abcyixyz/Stm32F407_USB_OTG_HS)\n\n## 1.RT-Thread Studio\n\nNew >> RT-Thread Protect  \n\n![image-20210630223400016](image-20210630223400016.png)\n\n\n\n## 2.CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)  \n2. System Core >> SYS >> Debug(选择调试接口)   \n3. Connectivity >> USART1 >> Asynchronous(用于finsh命令行)  \n4. Connectivity >> USB_OTG_HS >> Host_Only(开发板无供电控制故未勾选VBUS)  \n\n![image-20210630223923547](image-20210630223923547.png)\n\n1. Enable HS global interrupt\n\n![image-20210630223948843](image-20210630223948843.png)\n\n6. Clock Configuration(配置时钟)\n\n   HCLK >> 168  >> Enter\n\n![image-20210630224636418](image-20210630224636418.png)\n\n7. GENERATE COED (default seting)\n\n![image-20210630224256382](image-20210630224256382.png)\n\n![image-20210630224307585](image-20210630224307585.png)\n\n\n\n## 3.Code\n\n---\n\n1. *applications/main.c*\n\n```c\n#define DBG_TAG \"main\"\n//#define DBG_LVL DBG_INFO\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n```\n\n2. *drivers/board.h*\n\n```c\n#define BSP_USING_UART1\n#define BSP_UART1_TX_PIN       \"PA9\"\n#define BSP_UART1_RX_PIN       \"PA10\"\n\n#define BSP_USING_USBHOST\n#define BSP_USBD_TYPE_HS\n```\n\n3. *drivers/drv_clk.c* (copy from *cubemx/Src/main.c*)\n\n```c\nvoid SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\n\n  /** Configure the main internal regulator output voltage\n  */\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);\n  /** Initializes the RCC Oscillators according to the specified parameters\n  * in the RCC_OscInitTypeDef structure.\n  */\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLM = 25;\n  RCC_OscInitStruct.PLL.PLLN = 336;\n  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;\n  RCC_OscInitStruct.PLL.PLLQ = 7;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Initializes the CPU, AHB and APB buses clocks\n  */\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)\n  {\n    Error_Handler();\n  }\n}\n\n//void system_clock_config(int target_freq_mhz)\n//{\n//...\n//}\n```\n\n4. new source file  \n\n![image-20210630224927209](image-20210630224927209.png)\n\n5. `applications/filesystem.c`\n\n```C\n#include <rtthread.h>\n#include <dfs_fs.h>\n#include \"dfs_romfs.h\"\n\n#define DBG_TAG \"app.filesystem\"\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n\nstatic const struct romfs_dirent _romfs_root[] = {\n    {ROMFS_DIRENT_DIR, \"udisk\", RT_NULL, 0}\n};\n\nconst struct romfs_dirent romfs_root = {\n    ROMFS_DIRENT_DIR, \"/\", (rt_uint8_t *)_romfs_root, sizeof(_romfs_root) / sizeof(_romfs_root[0])\n};\n\nint mount_init(void)\n{\n    if (dfs_mount(RT_NULL, \"/\", \"rom\", 0, &(romfs_root)) != 0)\n    {\n        LOG_E(\"rom mount to '/' failed!\");\n        return RT_ERROR;\n    }\n    return RT_EOK;\n}\nINIT_APP_EXPORT(mount_init); \n```\n\n6. drivers/drv_common.c\n\n[STM32F407遇到USB读取U盘无法读取问题](https://club.rt-thread.org/ask/question/427531.html)\n\n```C\nvoid HAL_Delay(__IO uint32_t Delay)\n{\n    rt_thread_mdelay(Delay);\n}\n```\n\n7. drivers/drv_usbh.c\n\n```c\n#define DBG_TAG \"drv_usbh\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\n/* add OTG_HS_IRQ */\nvoid OTG_HS_IRQHandler(void)\n{\n    rt_interrupt_enter();\n    HAL_HCD_IRQHandler(&stm32_hhcd_fs);\n    rt_interrupt_leave();\n}\n\n/* cubemx/Src/main.c >> static void MX_USB_OTG_HS_HCD_Init(void) */\n#ifdef BSP_USBD_TYPE_HS\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_HS;\n    hhcd->Init.Host_channels = 12;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = USB_OTG_EMBEDDED_PHY;\n    hhcd->Init.Sof_enable = DISABLE;\n    hhcd->Init.low_power_enable = DISABLE;\n    hhcd->Init.vbus_sensing_enable = DISABLE;\n    hhcd->Init.use_external_vbus = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n\n#else\n\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_FS;\n    hhcd->Init.Host_channels = 8;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = HCD_PHY_EMBEDDED;\n    hhcd->Init.Sof_enable = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n#endif\n```\n\n\n\n## RT-Thread Settings\n---\n\n1. Exclude from Build\n\n~~cubemx/Src/main.c~~  \n~~cubemx/Src/stm32f4xx_it.c~~  \n\n![image-20210630224537429](image-20210630224537429.png)\n\n![image-20210630225754496](image-20210630225754496.png)\n\n2. Components >> Device Drivers >> Using USB >> Using USB host >> Enable Udisk Drivers >> Udisk mount dir >> /udisk\n\n![image-20210630225432224](image-20210630225432224.png)\n\n3. Components >> Device virtual file system >> Using device virtual file system >> Enable elm-chan fatfs  /  Enable ReadOnlay file system on flash\n\n![image-20210630225517213](image-20210630225517213.png)\n\n## 4.Test\n\n---\n1. Build and Flash download\n2. Terminal\n\n<kbd>Ctrl</kbd>+<kbd>Atl</kbd>+<kbd>Shift</kbd> +<kbd>T</kbd>\n\n![image-20210630225624874](image-20210630225624874.png)\n\n3. Insert the u-disk(插入U盘)\n\n![image-20210630225644852](image-20210630225644852.png)\n\n","tags":["STM32"]},{"title":"Archlinux下rCore 实验环境配置","url":"/2021/03/21/Archlinux下rCore-实验环境配置/","content":"\n## 1.Archlinux下rCore 实验环境配置\n\n原文：[rCore-Tutorial-Book 第三版 实验环境配置](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#rust)\n\n+ 系统环境配置（使用Archlinux）\n+ Rust开发环境配置\n+ Qemu模拟器安装\n+ GDB 调试支持\n\n## 2.Rust 开发环境配置\n\n首先安装Rust包管理器cargo和Rust版本管理器rustup\n\n```bash\nsudo pacman -S cargo\nsudo pacman -S rustup\n```\n\n修改Rust Crates源 [ustc](https://mirrors.ustc.edu.cn/help/crates.io-index.html)，在 `$HOME/.cargo/config` 中添加如下内容：\n\n```bash\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n可通过如下命令安装rustc的nightly版本（rCore要求用rustc的nightly版本），并把该版本设置为rustc的缺省版本\n\n```bash\nrustup install nightly\nrustup default nightly\n```\n\n接下来安装一些Rust相关的软件包\n\n```bash\nrustup target add riscv64gc-unknown-none-elf\ncargo install cargo-binutils\nrustup component add llvm-tools-preview\nrustup component add rust-src\n```\n\n## 3.Qemu 模拟器安装\n\n```bash\nsudo pacman -S qemu-emulators-full\n```\n\n随后即可在当前终端 `source ~/.bashrc` 更新系统路径，或者直接重启一个新的终端。此时我们可以确认 Qemu 的版本\n\n```bash\nqemu-system-riscv64 --version\nqemu-riscv64 --version\n```\n\n## 4.GDB 调试支持\n\n在 `os` 目录下 `make debug` 可以调试我们的内核，这需要安装终端复用工具 `tmux` ，还需要基于 riscv64 平台的 gdb 调试器 `riscv64-unknown-elf-gdb` 。该调试器包含在 riscv64 gcc 工具链中。\n\n```bash\nyay -S riscv64-unknown-elf-gdb\n```\n\n## 5.运行 rCore-Tutorial-v3\n\n如果是在 Qemu 平台上运行，只需在`os`目录下 `make run` 即可。在内核加载完毕之后，可以看到目前可以用的 应用程序。 `usertests` 打包了其中的很大一部分，所以我们可以运行它，只需输入在终端中输入它的名字即可。运行后，可以先按下 `Ctrl+A` ，再按下 `X` 来退出 Qemu。","tags":["Rust"]},{"title":"Mosquitto 搭建及配置","url":"/2021/03/21/Mosquitto-搭建及配置/","content":"\n## 1.概述\n\nEclipse Mosquitto是一个开源消息代理，实现了MQTT协议版本3.1和3.1.1。Mosquitto轻量，适用于低功耗单板计算机到完整服务器的所有设备。Mosquitto项目还提供了用于实现MQTT客户端的C库以及非常受欢迎的mosquitto_pub和mosquitto_sub命令行MQTT客户端。\n\n其他服务器代理实现:https://github.com/mqtt/mqtt.github.io/wiki/servers\n 各操作系统安装指引:https://mosquitto.org/download/\n\n## 2.下载安装\n\n以Ubuntu为例\n\n- 更新源\n\n```bash\nsudo apt-get update\n```\n\n- 安装服务器端\n\n```bash\nsudo apt-get install mosquitto\n```\n\n+ 安装客户端\n\n```bash\nsudo apt-get install mosquitto-clients\n```\n\n## 3.配置\n\n### 3.1主配置文件mosquitto.conf\n\n```nginx\nid_file /var/run/mosquitto.pid\n\n# 消息持久存储\npersistence true\npersistence_location /var/lib/mosquitto/\n\n# 日志文件\nlog_dest file /var/log/mosquitto/mosquitto.log\n\n# 其他配置\ninclude_dir /etc/mosquitto/conf.d\n\n# 禁止匿名访问\nallow_anonymous false\n# 认证配置\npassword_file /etc/mosquitto/pwfile\n# 权限配置\nacl_file /etc/mosquitto/aclfile\n```\n\n### 3.2认证配置pwfile\n\n- 创建密码存储文件\n\n```bash\nsudo touch /etc/mosquitto/pwfile\n```\n\n- 服务开启后,输入如下命令,根据提示输入两遍密码\n\n```bash\nmosquitto_passwd /etc/mosquitto/pwfile 用户名\n```\n\n### 3.3权限配置aclfile\n\n- 打开文件\n\n```bash\nvim /etc/mosquitto/aclfile\n```\n\n- 编辑内容\n\n```nginx\n# 李雷只能发布以test为前缀的主题,订阅以$SYS开头的主题即系统主题\nuser lilei\ntopic write test/#\ntopic read $SYS/#\n\n# 韩梅梅只能订阅以test为前缀的主题\nuser hanmeimei\ntopic read test/#\n```\n\n## 4.启动\n\n-c：指定特定配置文件启动\n-d：后台运行\n\n```bash\nmosquitto -c /etc/mosquitto/mosquitto.conf -d\n```\n\n### 4.1测试\n\n发布使用mosquitto_pub命令，订阅使用mosquitto_sub命令。常用参数介绍：\n\n| 参数 | 描述                      |\n| ---- | ------------------------- |\n| -h   | 服务器主机，默认localhost |\n| -t   | 指定主题                  |\n| -u   | 用户名                    |\n| -P   | 密码                      |\n| -i   | 客户端id，唯一            |\n| -m   | 发布的消息内容            |\n\n订阅\n\n```bash\nmosquitto_sub -h localhost -t \"test/#\" -u hanmeimei -P 123456 -i \"client1\"\n```\n\n订阅系统主题\n\n```bash\n# 订阅客户端存活连接数\nmosquitto_sub -h localhost –t '$SYS/broker/clients/active' -u lilei -P 123456 -i \"client2\"\n```\n\n发布\n\n```bash\nmosquitto_pub -h localhost -t \"test/abc\" -u lilei -P 123456 -i \"client3\" -m \"How are you?\"\n```\n\n## 5.参考链接\n\n- 项目网站：https://www.eclipse.org/paho\n- Eclipse项目信息：https://projects.eclipse.org/projects/iot.paho\n- GitHub：https://github.com/eclipse/paho.mqtt.java\n- MQTT Java客户端的使用：https://www.jianshu.com/p/65e1748a930c\n- Spring支持：https://www.jianshu.com/p/6b60858b7d44","tags":["IoT"]},{"title":"Gitblit 安装使用","url":"/2020/11/22/Gitblit-安装使用/","content":"\nGitblit是一个在Java环境中运行的Git服务器。在这里记录一下在Windows上搭建Gitblit服务的过程。\n\n[Gitblit](https://gitblit.github.io/gitblit/) is an open-source, pure Java stack for managing, viewing, and serving Git repositories.\nIt's designed primarily as a tool for small workgroups who want to host centralized repositories.\n\n## 1.准备文件\n\n* jdk-11.0.2_windows-x64_bin.zip[华为源](https://repo.huaweicloud.com/java/jdk/)\n* gitblit安装包[Gitblit](https://gitblit.github.io/gitblit/)\n\n## 2.安装Java\n\n请参考[菜鸟教程](https://www.runoob.com/java/java-environment-setup.html)\n\n## 3.配置Gitblit\n1. 下载的zip文件只要解压缩即可，不用安装。建议放到D:\\Program Files\\gitblit-xxx目录中（xxx指版本号）\n2. 新建一个用于存放git服务器数据的文件夹，如D:\\GitBlit_repository\n3. 配置gitblit.properties 文件。  \n    * 在D:\\Program Files\\gitblit-xxx\\data目录中将defaults.properties文件复制一份，改名为my.properties  \n    * 修改gitblit.properties文件，然后将 `include = defaults.properties` 注释掉  \n    * 添加一代码`include = my.properties`表示使用my.properties这个配置。  \n4. 修改my.properties文件中的端口和服务器IP地址：  \n    * 修改git.repositoriesFolder = D:/Gitblit_repository（注意其中的D:\\Gitblit_repository 中的\"\\\"一定要用\"/\"。）  \n    * 修改server.httpPort = 10101  \n    * 修改server.httpBindInterface = 192.168123.15（我自己的服务器IP地址为192.168.123.15）  \n    * 修改server.httpsBindInterface = localhost  \n    * 最后修改server.certificateAlias = localhost\n5. 运行Gitblit服务。在D:\\Program Files\\gitblit-xxx目录下运行gitblit.cmd命令。注意看命令行中的提示，检查程序是否运行正常。\n6. 命令行中会有服务器ip和端口号请注意查看。\n\n## 4.管理GitBlit\n\n在浏览器地址栏中输入命令行中提示的服务器ip和端口号\n\n如果成功加载，说明服务器搭建完毕。默认账号密码均为admin\n\n## 5.设置开启自启动\n\n设置以Windows Service方式启动Gitblit.  \n1. 在Gitblit目录下，找到installService.cmd文件。鼠标右键使用记事本打开。  \n2. 设置 CD 为程序目录 `SET CD=D:\\Program Files\\gitblit-xxx(xxx修改为你自己的目录)`  \n3. 保存，关闭文件\n4. 右键installService.cmd文件，选择以管理员的身份运行  \n5. 点击开始菜单输入services.msc 打开Windows服务查找gitblit，如果未启动，请手动启动。注意确保为自动模式，这样每次windows启动后都自动启动此项服务。","tags":["Gitblit"]},{"title":"Hello World","url":"/2020/05/24/hello-world/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]